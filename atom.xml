<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>VinnyXiong&#39;s Notes</title>
  
  <subtitle>熊远文的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://vinnyxiong.cn/"/>
  <updated>2017-08-11T11:54:22.000Z</updated>
  <id>http://vinnyxiong.cn/</id>
  
  <author>
    <name>熊远文(vinnyxiong)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【转载】Meteor-DDP 翻译</title>
    <link href="http://vinnyxiong.cn//blog/Meteor-DDP-translate.html"/>
    <id>http://vinnyxiong.cn//blog/Meteor-DDP-translate.html</id>
    <published>2017-08-11T11:18:56.000Z</published>
    <updated>2017-08-11T11:54:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载来源：<a href="https://cnodejs.org/topic/51b030d9555d34c678e5fb2e" target="_blank" rel="noopener">Meteor-DDP翻译</a></p></blockquote><h1 id="DDP定义"><a href="#DDP定义" class="headerlink" title="DDP定义"></a>DDP定义</h1><p><code>DDP</code>是一个<code>客户端</code>和<code>服务端</code>之间的协议，他支持两种操作：</p><ul><li>由<code>客户端</code>向<code>服务端</code>发起远程过程调用</li><li><code>客户端</code>订阅数据，在他们变化时，<code>服务器</code>仍然保持向客户端发起通知。</li></ul><p>本文定义了版本为”<code>pre1</code>“的<code>DDP</code>，以上仅仅是粗略的描述而非完整明确的定义。</p><h1 id="一般消息结构"><a href="#一般消息结构" class="headerlink" title="一般消息结构"></a>一般消息结构</h1><p>无论<code>SockJS</code>还是<code>WebSockets</code>，<code>DDP</code>都将使用较低级别的消息传输方式。（现在，你可以通过<code>URL</code>连接<code>SockJS</code>的<code>/sockjs以及WebSockets的/websocket</code>。后者很可能将改变为主应用<code>URL</code>指定的<code>WebSocket</code>子协议）</p><p><code>DDP</code>消息就是指定了<code>EJSON</code>类型字段的<code>JSON</code>对象。每个消息都有一个<code>msg</code>字段来指定消息类型，或根据其他字段确定消息类型。<br><a id="more"></a></p><h1 id="建立DDP连接"><a href="#建立DDP连接" class="headerlink" title="建立DDP连接"></a>建立DDP连接</h1><h2 id="message分类"><a href="#message分类" class="headerlink" title="message分类"></a>message分类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">connect （client → server）</span><br><span class="line">session : string （尝试连接到现有DDP会话）</span><br><span class="line">version : string （拟定的协议版本）</span><br><span class="line">support : [string] （客户端支持的协议版本，按优先顺序排列）</span><br><span class="line">connected （server → client）</span><br><span class="line">session : string （DDP会话标识）</span><br><span class="line">failed （server → client）</span><br><span class="line">version : string （建议连接协议版本）</span><br></pre></td></tr></table></figure><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p><code>服务器</code>可能会发送一个缺失键名为<code>msg</code>的初始化<code>message</code>，如果是这样的，<code>客户端</code>会忽略它，也不会等待此<code>message</code>。（此<code>message</code>是通过<code>SockJS</code>传输帮助实现<code>代码热部署</code>的，可能不应该，但目前我们是通过<code>WebSocket</code>实现的）</p><ul><li><code>客户端</code>发送<code>connect</code>消息。</li><li>如果<code>服务器</code>允许通信的消息的<code>version</code>与接收到的<code>connect</code>消息匹配，<code>服务器</code>会发送<code>connected</code>消息。</li><li>否则<code>服务器</code>会关闭底层传输，发送<code>failed</code>消息，告之允许通信的<code>DDP</code>版本以及<code>connect</code>消息中的<code>support</code>字段。</li><li><code>客户端</code>建新<code>connect</code>消息尝试使用不同版本的<code>DDP</code>连接。<code>客户端</code>会发送众多的<code>connect</code>消息，直到连接匹配。如果<code>服务器</code>还不支持，就会忽略掉这些附加信息。</li></ul><p><code>connect</code>消息的<code>support</code>字段存储的版本信息是根据<code>客户端</code>的喜好优先级排列的。如果按照这个顺序，由客户端提出的<code>version</code>不是<code>服务器</code>支持的，<code>服务器</code>必会发送<code>failed</code>消息，强制<code>客户端</code>切换到更好的版本。</p><p>当<code>客户端</code>第一次连接到服务器，他会设置<code>version</code>为自己最认可的版本。如果有需要，<code>客户端</code>可以记住最终能与<code>服务端</code>匹配的版本。如果<code>服务端</code>能拥有更好的版本或者<code>客户端</code>已经升级，<code>客户端</code>始终依靠<code>服务端</code>发来的<code>failed</code>消息。</p><h1 id="管理数据"><a href="#管理数据" class="headerlink" title="管理数据"></a>管理数据</h1><h2 id="message分类-1"><a href="#message分类-1" class="headerlink" title="message分类"></a>message分类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">sub （client → server）</span><br><span class="line">id : string （订阅的标识符）</span><br><span class="line">name : string （订阅的名字）</span><br><span class="line">params : [EJSON] （可选的订阅参数）</span><br><span class="line">unsub （client → server）</span><br><span class="line">id : string （sub消息中的id）</span><br><span class="line">nosub （server → client）</span><br><span class="line">id : string （sub消息中的id）</span><br><span class="line">error : Error（可选的错误，订阅错误总结或者订阅不存在等）</span><br><span class="line">added （server → client）</span><br><span class="line">collection : string （Collecction名字）</span><br><span class="line">id : string （Documentid）</span><br><span class="line">fields : EJSON （可选的EJSON值）</span><br><span class="line">changed （server → client）</span><br><span class="line">collection : string （Collecction名字）</span><br><span class="line">id : string （Documentid）</span><br><span class="line">fields : EJSON （可选的EJSON值）</span><br><span class="line">cleared : [string] （可选的，要删除的字段名）</span><br><span class="line">removed （server → client）</span><br><span class="line">collection : string （Collecction名字）</span><br><span class="line">id : string （Documentid）</span><br><span class="line">ready （server → client）</span><br><span class="line">subs : [string] （所有通过sub传递的id集）</span><br><span class="line">addedBefore （server → client）</span><br><span class="line">collection : string （Collecction名字）</span><br><span class="line">id : string （Documentid）</span><br><span class="line">fields : EJSON （可选的EJSON值）</span><br><span class="line">before : string/null （Document添加前的id，或者null表示添加完毕）</span><br><span class="line">movedBefore （server → client）</span><br><span class="line">collection : string （Collecction名字）</span><br><span class="line">id : string （Documentid）</span><br><span class="line">before : string/null （Document删除前的id，或者null表示删除完毕）</span><br></pre></td></tr></table></figure><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ul><li>客户端指定感兴趣的信息集，发送sub消息给服务器。</li><li>在任何时间里，sub消息都会被通知到，服务器再发送数据到客户端。数据包含了added、changed、removed消息。这些消息的本地数据模型将会被跟踪。<ul><li>added消息表示了本地数据集的一个Document。id字段将被指定为Document的id，其他字段将被指定为Document的其他字段。minimongo通过特殊的方式将id转化为_id以存储到Mongo的文档集中。</li><li>changed消息表示了本地数据集的一个Document有了新的字段值或某些字段被删除了。id字段指定了被改变了的Document的id，fields如果存在，表示文档中哪些字段值应该被替换。需要清除的字段应该放在cleared中以数组的形式呈现。</li><li>removed消息表示了本地数据集的一个Document需要删除了。id字段指定了需要删除的Document的id。</li></ul></li><li>如果一个Collection被订购过，addedBefore消息可以取代added消息。包含有该id的Document在被添加后可插入before字段。如果before字段设置为null,Document将被添加，直到结束。对于一个给定的集合，服务器只应发送added或addedBefore消息，而不是两者混合起来发。并且只能发送movedBefore消息给使用addedBefore消息的Collection。</li></ul><p><strong>注意 ：</strong></p><p>被订购过的<code>Collection</code>的<code>DDP</code>消息没有使用在<code>Meteor</code>中，不过今后将会使用。</p><ul><li>客户端保持每一个Collection的数据。每个订阅不会做自己的数据集，但重复订阅会导致服务器发送关于Collection数据的字段联盟。例如，订阅器A说文档x有字段{foo:1,bar:2},订阅器B说文档x有{foo:1,baz:3}，此时客户端将通知文档x拥有字段{foo:1,bar:2,baz:3}。如果字段值因为不同订阅器发生冲突，服务器会发送一个可用的字段值。</li><li>当一个或多个订阅完成首批数据的发送，服务器将发送ready消息并伴随他们的id信息。</li></ul><h1 id="远程过程调用"><a href="#远程过程调用" class="headerlink" title="远程过程调用"></a>远程过程调用</h1><h2 id="message分类-2"><a href="#message分类-2" class="headerlink" title="message分类"></a>message分类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">method （client → server）</span><br><span class="line">method : string （方法名）</span><br><span class="line">params : [EJSON] （可选的方法参数）</span><br><span class="line">id : string （方法调用的客户端标识）</span><br><span class="line">result （server → client）</span><br><span class="line">id : string （method消息中的id）</span><br><span class="line">error : Error （可选的，方法调用时的错误或者方法不存在）</span><br><span class="line">result : EJSON （可选的，方法的返回值）</span><br><span class="line">updated （server → client）</span><br><span class="line">methods : string （所有调用过method消息的id）</span><br></pre></td></tr></table></figure><h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h2><ul><li>客户端发送一个method消息到服务器</li><li>服务端响应一个result消息到客户端，带有方法调用的返回值或者错误信息。</li><li>如果客户端接受过订阅，方法调用将直接影响数据。一旦服务端基于此方式完成所有相应数据的发送，服务器会发送一个updated消息给客户端，并带有所有方法的id集。</li></ul><h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><p>result和nosub消息中会出现一个可选的error字段，一个错误消息具备如下字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error : number （错误号）</span><br><span class="line">reason : string （可选的错误原因）</span><br><span class="line">details : string （可选的错误详情）</span><br></pre></td></tr></table></figure><p>error用来呈现订阅或者远程调用方法时出现的错误信息，订阅不存在或者调用方法不存在时，也通过这个传递信息。</p><p>客户端也能发送其他的错误消息给服务端，这样的消息将以error为最顶级直接呈现，并包含以下信息：</p><ul><li>不合法的JSON对象信息</li><li>未知的msg类型</li><li>其他畸形客户端请求（不包括所需字段）</li><li>发送第一次connect消息或者connect消息初始化无关的其他内容</li></ul><p>这样的error消息将包含以下字段</p><ul><li>reason : string （描述错误的字符串）</li><li>offendingMessage : ** （包含原来解析正确的消息）</li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>做了两个例子，可以参照<a href="https://cnodejs.org/topic/51b03065555d34c678e5ee98" target="_blank" rel="noopener">这篇文章</a>做一下。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>EJSON是一种嵌入扩展JSON的JSON对象。他支持所有平时所见的JSON类型，同时附加了如下内容：</p><h1 id="Dates"><a href="#Dates" class="headerlink" title="Dates"></a>Dates</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;$date&quot;: MILLISECONDS_SINCE_EPOCH&#125;</span><br></pre></td></tr></table></figure><h1 id="Binary-data"><a href="#Binary-data" class="headerlink" title="Binary data:"></a>Binary data:</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;$binary&quot;: BASE_64_STRING&#125;</span><br></pre></td></tr></table></figure><p>基于64位字符串，有符号+和/，没有长度限制。</p><p><strong>转义内容</strong>，否则看上去更像是EJSON类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;$escape&quot;: THING&#125;</span><br></pre></td></tr></table></figure><p>例如，把<code>JSON</code>值<code>{$date:10000}</code>装进EJSON对象中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;$escape&quot;: &#123;&quot;$date&quot;: 10000&#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>转义内容的键必须存放在下级，你也可以再嵌套<code>EJSON</code>，例如，下面将<code>$date</code>映射到一个日期对象上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;$escape&quot;: &#123;&quot;$date&quot;: &#123;&quot;$date&quot;: 32491&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><h1 id="User-specified-types"><a href="#User-specified-types" class="headerlink" title="User-specified types"></a>User-specified types</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;$type&quot;: TYPENAME, &quot;$value&quot;: VALUE&#125;</span><br></pre></td></tr></table></figure><p>实现EJSON应尽量保证键位顺序。如果允许，也可以不必这样。</p><blockquote><p>MongoDB依赖键位顺序。在MongoDB中使用EJSON是，实现的EJSON必须保持键位顺序。</p></blockquote><p>有关EJSON的详细信息可以到Meteor的<a href="http://docs.meteor.com/api/ejson.html" target="_blank" rel="noopener">文档中心-EJSON</a>查阅，或是查看讲解<a href="http://www.eventedmind.com/posts/meteor-what-is-ejson" target="_blank" rel="noopener">EJSON的视频</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;转载来源：&lt;a href=&quot;https://cnodejs.org/topic/51b030d9555d34c678e5fb2e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Meteor-DDP翻译&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;DDP定义&quot;&gt;&lt;a href=&quot;#DDP定义&quot; class=&quot;headerlink&quot; title=&quot;DDP定义&quot;&gt;&lt;/a&gt;DDP定义&lt;/h1&gt;&lt;p&gt;&lt;code&gt;DDP&lt;/code&gt;是一个&lt;code&gt;客户端&lt;/code&gt;和&lt;code&gt;服务端&lt;/code&gt;之间的协议，他支持两种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由&lt;code&gt;客户端&lt;/code&gt;向&lt;code&gt;服务端&lt;/code&gt;发起远程过程调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;客户端&lt;/code&gt;订阅数据，在他们变化时，&lt;code&gt;服务器&lt;/code&gt;仍然保持向客户端发起通知。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文定义了版本为”&lt;code&gt;pre1&lt;/code&gt;“的&lt;code&gt;DDP&lt;/code&gt;，以上仅仅是粗略的描述而非完整明确的定义。&lt;/p&gt;
&lt;h1 id=&quot;一般消息结构&quot;&gt;&lt;a href=&quot;#一般消息结构&quot; class=&quot;headerlink&quot; title=&quot;一般消息结构&quot;&gt;&lt;/a&gt;一般消息结构&lt;/h1&gt;&lt;p&gt;无论&lt;code&gt;SockJS&lt;/code&gt;还是&lt;code&gt;WebSockets&lt;/code&gt;，&lt;code&gt;DDP&lt;/code&gt;都将使用较低级别的消息传输方式。（现在，你可以通过&lt;code&gt;URL&lt;/code&gt;连接&lt;code&gt;SockJS&lt;/code&gt;的&lt;code&gt;/sockjs以及WebSockets的/websocket&lt;/code&gt;。后者很可能将改变为主应用&lt;code&gt;URL&lt;/code&gt;指定的&lt;code&gt;WebSocket&lt;/code&gt;子协议）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DDP&lt;/code&gt;消息就是指定了&lt;code&gt;EJSON&lt;/code&gt;类型字段的&lt;code&gt;JSON&lt;/code&gt;对象。每个消息都有一个&lt;code&gt;msg&lt;/code&gt;字段来指定消息类型，或根据其他字段确定消息类型。&lt;br&gt;
    
    </summary>
    
      <category term="Meteor" scheme="http://vinnyxiong.cn/categories/Meteor/"/>
    
    
      <category term="Meteor" scheme="http://vinnyxiong.cn/tags/Meteor/"/>
    
      <category term="DDP" scheme="http://vinnyxiong.cn/tags/DDP/"/>
    
  </entry>
  
  <entry>
    <title>2017 夏至已至</title>
    <link href="http://vinnyxiong.cn//blog/life-2017-summer-time.html"/>
    <id>http://vinnyxiong.cn//blog/life-2017-summer-time.html</id>
    <published>2017-07-12T02:05:56.000Z</published>
    <updated>2018-01-20T13:04:40.099Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/blog_post_images/2017-07/2017-07-11-summer.jpg"><a id="more"></a><p>最近所在的部门在做一款应用于办公场景的即时通讯软件-<a href="http://office.qq.com/" target="_blank" rel="noopener">TIM</a>。公司在这方面的探索也有一段时间，今年3月份终于发布了正式版。</p><p>记得去年做的第一个版本，自己也负责了其中最重要的一个模块的开发，当时真的是花了很多的时间和精力去做好其中的每一个功能，尽力去优化到最佳体验。但是没过多久，由于产品策略的调整，还没正式发布，整个产品就被砍掉了，当时听到这个消息的时候有太多的不舍，曾经花费那么多心血，熬了多少个日夜写出的一行行代码，还没能跟用户见面，就永久地封存了，从此成为了历史。在这个变幻莫测的互联网时代，你写的大多数代码很可能运行一两年甚至半年，就变成了历史的尘埃。</p><p>今年以来，产品渐渐找到了方向，正式发布之后，用户量也在稳健提升。但是反而感觉没有做出更多亮点的功能出来。自己在办公场景的应用也有很多的想法，并且也尝试做了一些Demo出来，不过产品经理们对此并不是很在意，作为一个开发，真的是决定不了太多产品的方向，好在领导还比较认可，也鼓励我们主动思考创新。</p><p>2017年，深圳的夏季格外炎热，毕业工作已经五年了，来到深圳也已两年有余。关于技术，总感觉还有很多地方都是懵懵懂懂，在学习上还缺乏一股劲。</p><p>最近很火的“人工智能”，以及前段时间像是要火的“VR”和“AR”，现在都还没有碰过，从PC互联网时代走到了移动互联网时代，现在大家都说下一次将是人工智能时代，再不学习，我们都会被淘汰了，公司内也是铺天盖地的人工智能风潮。如果真的要切入人工智能领域，需要有足够的数学基础知识，在这方面我还非常的欠缺。当然，第一个阶段可以先从应用层入手，只需要在前人的基础上调调参数就可以了，或许也是一个切入点。</p><p>最后，免不了还是要定一个计划了，今后的一年，计划开始学习人工智能相关的知识，也不知道能学到什么程度，不定目标，总要现有这样的计划，开个头慢慢学习吧。</p><p><em>—————— 2017年7月12日 晨 深圳南山</em></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/images/blog_post_images/2017-07/2017-07-11-summer.jpg&quot;&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="http://vinnyxiong.cn/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="公司" scheme="http://vinnyxiong.cn/tags/%E5%85%AC%E5%8F%B8/"/>
    
      <category term="工作" scheme="http://vinnyxiong.cn/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="学习" scheme="http://vinnyxiong.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>我的博客</title>
    <link href="http://vinnyxiong.cn//blog/life-my-blogs.html"/>
    <id>http://vinnyxiong.cn//blog/life-my-blogs.html</id>
    <published>2017-02-13T14:21:14.000Z</published>
    <updated>2017-07-12T01:46:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>大概高中的时候，坚持过一段时间每天写日记，不过都是写些鸡毛蒜皮的碎碎念，终究也没有坚持下去。大学的时候，看过很多人的技术博客，也曾想在 <a href="http://blog.csdn.net/xyw20082101028" target="_blank" rel="noopener">CSDN</a> 上写博客，但最终也是不了了之。唉，始终没能养成写作记录的习惯。<br><a id="more"></a></p><p>直到前年，由 C++ 开发转到做 iOS 开发，又开始大量阅读技术大神的博客，并且发现了 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 这样的完全自由的基于 <code>github Pages</code> 服务的个人静态博客，我感觉到这正是我心目中理想的博客的样子<em>（惭愧地是，这类的博客很早之前就已经有了，竟然现在才发现）</em>。便再次萌生了写博客的想法，并且也正想记录下 iOS 开发的学习过程，以及生活中的事。在此，要感谢 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 的作者 <a href="http://twitter.com/tommy351" target="_blank" rel="noopener">@tommy351</a>，为我们提供了高效自由的博客模板。另外还要感谢本博客使用的主题 <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT</a> 的作者 <a href="http://notes.iissnan.com/" target="_blank" rel="noopener">@IIssNan</a> 为我们提供了一个功能丰富，但是风格优雅极简的博客主题。</p><p>当初还为博客购买了域名 <a href="http://vinnyxiong.cn/">vinnyxiong.cn</a> ，囧，当时为了省钱，只买了 <code>.cn</code> 中国一级域名，现在想想应该购买 <code>.com</code> 的国际一级域名，或者更具科技范的 <code>.net</code> 或 <code>.me</code> 域名的。</p><p>博客建立一年有余，然而产出却非常可怜，过去的一年多，工作也比较忙碌，没有更多的时间来写博客，不过说到底，还是因为自己太懒了吧。仅有的几篇博客写的都是技术相关的，明明建立博客的初衷是一个综合性的博客，却被我写成了纯技术的博客。</p><p>今年工作上稍微不是那么忙碌，而且今年年中也有一次晋级答辩，需要更多的钻研技术，并且多多总结经验，希望今年本博客能够有更多高质量的技术文章产出。并且也更多地记录一些生活上学习上的事情，若干年后回头来看看自己写的东西，应该会很有趣吧。</p><p>以上，本博第一篇非技术文章，作为开启综合性博客的开端吧。</p><p><em>—————— 2017年2月13日 晚 深圳宝安</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概高中的时候，坚持过一段时间每天写日记，不过都是写些鸡毛蒜皮的碎碎念，终究也没有坚持下去。大学的时候，看过很多人的技术博客，也曾想在 &lt;a href=&quot;http://blog.csdn.net/xyw20082101028&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSDN&lt;/a&gt; 上写博客，但最终也是不了了之。唉，始终没能养成写作记录的习惯。&lt;br&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="http://vinnyxiong.cn/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="博客" scheme="http://vinnyxiong.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="生活" scheme="http://vinnyxiong.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>iOS 平台 TestFlight 外部测试邀请码优化方案</title>
    <link href="http://vinnyxiong.cn//blog/iOS-%E5%B9%B3%E5%8F%B0-TestFlight-%E5%A4%96%E9%83%A8%E6%B5%8B%E8%AF%95%E9%82%80%E8%AF%B7%E7%A0%81%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88.html"/>
    <id>http://vinnyxiong.cn//blog/iOS-平台-TestFlight-外部测试邀请码优化方案.html</id>
    <published>2017-01-20T12:16:32.000Z</published>
    <updated>2017-02-05T09:10:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h1><p>iOS 应用版本灰度测试是一个越来越令人头疼的一件事。<br>在 iOS9.0 之后，iOS 越狱设备越来越少，想要找到参与灰度测试的越狱用户越来越难。现在苹果企业签名的包外发控制越来越严格，这条路也很难走了。<br>因此，只能走苹果官方推荐的方式，通过 TestFlight 进行邀请测试。</p><p>关于 TestFlight 使用方法，已经有很多人总结过了，这里不赘述。比如：<br><a href="https://blog.coding.net/blog/ios-testFlight" target="_blank" rel="noopener">iOS 平台如何使用 TestFlight 进行 Beta 测试</a></p><p>TestFlight 的测试分为“内部测试”和“外部测试”，“内部测试”能邀请的人数比较少，只有 25 人，适用于内部测试人员测试功能，“外部测试”可以邀请 2000 人，适用于发布正式版之前进行灰度测试。本文主要描述的是“外部测试”的方案。<br><a id="more"></a></p><h1 id="2-TestFlight-标准流程"><a href="#2-TestFlight-标准流程" class="headerlink" title="2 TestFlight 标准流程"></a>2 TestFlight 标准流程</h1><ol><li>收集外部测试用户的邮箱（这个邮箱不一定是 Apple ID 邮箱）。</li><li>提交 TestFlight 测试版本，等待审核通过。</li><li>审核通过后，在 TestFlight 中导入灰度用户名单。</li><li>等待用户接收邀请测试的邮件，并预先到 AppStore 安装 TestFlight。</li><li>用户点击邮件中的 <code>Start Testing</code> 打开有“邀请码”的页面，复制 8 位大写英文字母的“邀请码”。。</li><li>用户打开 TestFlight（需要登录 Apple ID），点击下方的 <code>Redeem</code> ，将“邀请码”粘贴到输入框中，点击右上角的 <code>Redeem</code> ,即可开始下载测试的 App 。</li></ol><p><strong>流程中一个很重要的点是“邮箱”，这是苹果连接用户的唯一媒介。在现实中，收集用户邮箱不是一件很容易的事情，很难在短时间内联系到大量的用户，并提供邮箱，或者有些人很少打开邮箱，或者在手机上不方便打开邮箱。导致灰度测试效果不好，即使费时费力搜集了用户的邮箱，转化率也可能不高。</strong></p><blockquote><p>思考：有没有办法简化“邮箱”这一步呢？</p></blockquote><h1 id="3-TestFlight-优化流程"><a href="#3-TestFlight-优化流程" class="headerlink" title="3 TestFlight 优化流程"></a>3 TestFlight 优化流程</h1><p>从上述流程中可知，邮箱不一定是 Apple ID 邮箱，只要能接受苹果发出的 TestFlight 的邮件就可以，用户收到邮件后，是通过点击邮件中的链接来获取到“邀请码”的，为这个优化留下了可能性。</p><p><strong>优化目标：用户可以直接拿到“邀请码”，直接在 TestFlight 输入邀请码后下载 App。</strong></p><h2 id="3-1-准备-2000-个内部邮箱，用来接收-TestFlight-的邀请邮件"><a href="#3-1-准备-2000-个内部邮箱，用来接收-TestFlight-的邀请邮件" class="headerlink" title="3.1 准备 2000 个内部邮箱，用来接收 TestFlight 的邀请邮件"></a>3.1 准备 2000 个内部邮箱，用来接收 TestFlight 的邀请邮件</h2><p>可以通过某些途径，在内部准备好 2000 个邮箱，什么 QQ邮箱、163邮箱、126邮箱、新浪邮箱、hotmail、gmail 等等一批免费邮箱，而且每个邮箱都还能设置几个不同名的账户，比如一个 QQ 号排除手机号之外就可以有 4 个邮箱名（<code>123456@qq.com</code>, <code>xyz@qq.com</code>, <code>xyz@vip.qq.com</code>, <code>xyz@foxmail.com</code>）。所以要准备 2000 个邮箱账号也不是特别难的事情。不过为了方便自动化，最好还是申请单独某个类型的邮箱好一点，后面会说到。</p><h2 id="3-2-提取邀请邮件中的邀请链接"><a href="#3-2-提取邀请邮件中的邀请链接" class="headerlink" title="3.2 提取邀请邮件中的邀请链接"></a>3.2 提取邀请邮件中的邀请链接</h2><p>收到的“邀请邮件”中有个 <code>Start Testing</code> 的按钮，点击之后打开一个有“邀请码”的页面。</p><img src="/images/blog_post_images/2017-01/2017-01-20-TestFlight邀请邮件.png" title="TestFlight邀请邮件"><img src="/images/blog_post_images/2017-01/2017-01-20-TestFlight邀请码.png" title="TestFlight邀请码"><p>如果要一封一封邮件点开来查看邀请码，那确实也太费人力了，这里能否开发一个自动化工具来查看邮件呢？应该也不是特别难的事情，苹果的邮件格式基本上是固定的，这个自动化工具开发好之后是一劳永逸的事情。</p><p><code>Start Testing</code> 打开的链接格式大概是这样的：<br><a href="https://beta.itunes.apple.com/v1/invite/1ae8b3e5f47847d7a6a798222e2a2ef96fd24005bce24ff8a4de5bd41c5dc882460c5711?ct=TencentTechnologyShanghaiCoLtd&amp;advp=10000&amp;platform=ios" target="_blank" rel="noopener">https://beta.itunes.apple.com/v1/invite/1ae8b3e5f47847d7a6a798222e2a2ef96fd24005bce24ff8a4de5bd41c5dc882460c5711?ct=TencentTechnologyShanghaiCoLtd&amp;advp=10000&amp;platform=ios</a></p><p>打开链接之后，Chrome 可以通过开发者工具查看页面元素，如此可以开发一个自动化提取“邀请码”的工具。</p><img src="/images/blog_post_images/2017-01/2017-01-20-TestFlight邀请码代码.png" title="TestFlight邀请码代码"><h2 id="3-3-优化后的流程"><a href="#3-3-优化后的流程" class="headerlink" title="3.3 优化后的流程"></a>3.3 优化后的流程</h2><ol><li>提交 TestFlight 测试版本，等待审核通过。</li><li>审核通过后，在 TestFlight 中导入事先准备的 2000 个邮箱账号。</li><li>等待接收邀请测试的邮件，待接收到之后，通过自动化工具提取邀请链接，并保存。</li><li>通过自动化工具打开邀请链接提取“邀请码”。</li><li>将邀请码直接发放给灰度测试用户。</li><li>用户打开 TestFlight（需要登录 Apple ID），点击下方的 <code>Redeem</code> ，将“邀请码”粘贴到输入框中，点击右上角的 <code>Redeem</code> ,即可开始下载测试的 App 。</li></ol><h2 id="3-4-优化后的流程优点分析"><a href="#3-4-优化后的流程优点分析" class="headerlink" title="3.4 优化后的流程优点分析"></a>3.4 优化后的流程优点分析</h2><ol><li>免去了前期收集用户邮箱的困难，而且每次的版本灰度测试，每个 App 的版本灰度测试，都要做一遍这个事情，消耗大量的运营精力，而且效果可能还不是很好。</li><li>有时候可能不一定一开始就能收集到那么多的用户，可能是一批一批地邀请用户，也免去了每次去 iTunes Connect 添加邮箱的麻烦。</li><li>2000 个测试名额，可以最大化地利用，按需分配邀请码，而不是添加了一堆不参与测试的用户邮箱。</li><li>一套方案，可以多个项目使用，甚至可以推广至全公司。最终做出一个自动化的工具或框架，任意App可以接入，也不需要理解太多细节。</li></ol><p>上面优化后的流程中的第 4 点，是打开邀请链接之后提取“邀请码”出来，最后直接分配“邀请码”给用户，但是这里有一个坑，<strong>“邀请码”只有两个小时有效期</strong>，如果我们把邀请码提取出来了，必须在两个小时之内，发放给用户，并且在 TestFlight 中激活使用，否则“邀请码”会过期。不过过期之后，重新打开邀请链接，会生成新的“邀请码”。</p><p>另一个方案是直接把“邀请链接”发放给用户，让用户在开始体验 App 时，点开链接提取“邀请码”。</p><p>这两种方案各有利弊，发放“邀请码”给用户的方式，减少用户的学习成本。而且可以更加最大化地利用测试名额，第一次发放“邀请码”之后，如果两个小时之内用户没有使用。那么该邮箱的名额不会浪费，可以重新通过自动化工具提取“新的邀请码”，发放给第二批用户。</p><h1 id="4-尾巴"><a href="#4-尾巴" class="headerlink" title="4 尾巴"></a>4 尾巴</h1><p>上面是我在通过 TestFlight 邀请外部测试时遇到的一些问题，和对优化流程的想法，欢迎讨论，谢谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1 背景&quot;&gt;&lt;/a&gt;1 背景&lt;/h1&gt;&lt;p&gt;iOS 应用版本灰度测试是一个越来越令人头疼的一件事。&lt;br&gt;在 iOS9.0 之后，iOS 越狱设备越来越少，想要找到参与灰度测试的越狱用户越来越难。现在苹果企业签名的包外发控制越来越严格，这条路也很难走了。&lt;br&gt;因此，只能走苹果官方推荐的方式，通过 TestFlight 进行邀请测试。&lt;/p&gt;
&lt;p&gt;关于 TestFlight 使用方法，已经有很多人总结过了，这里不赘述。比如：&lt;br&gt;&lt;a href=&quot;https://blog.coding.net/blog/ios-testFlight&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iOS 平台如何使用 TestFlight 进行 Beta 测试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;TestFlight 的测试分为“内部测试”和“外部测试”，“内部测试”能邀请的人数比较少，只有 25 人，适用于内部测试人员测试功能，“外部测试”可以邀请 2000 人，适用于发布正式版之前进行灰度测试。本文主要描述的是“外部测试”的方案。&lt;br&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://vinnyxiong.cn/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="TestFlight" scheme="http://vinnyxiong.cn/tags/TestFlight/"/>
    
  </entry>
  
  <entry>
    <title>iOS-OC实现LRU算法NSDictionary容器（非线程安全）</title>
    <link href="http://vinnyxiong.cn//blog/iOS-OC%E5%AE%9E%E7%8E%B0LRU%E7%AE%97%E6%B3%95NSDictionary%E5%AE%B9%E5%99%A8%EF%BC%88%E9%9D%9E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%89.html"/>
    <id>http://vinnyxiong.cn//blog/iOS-OC实现LRU算法NSDictionary容器（非线程安全）.html</id>
    <published>2016-08-02T09:30:17.000Z</published>
    <updated>2016-08-16T11:52:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-LRU算法"><a href="#1-LRU算法" class="headerlink" title="1 LRU算法"></a>1 LRU算法</h2><blockquote><p><strong>LRU（Least recently used，最近最少使用）</strong>算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p></blockquote><a id="more"></a><p>这篇文章对LRU缓存算法做了非常详细的介绍：<a href="http://www.cnblogs.com/-OYK/archive/2012/12/05/2803317.html" target="_blank" rel="noopener">缓存淘汰算法之LRU-OYK</a></p><p>可惜<code>Foundation</code>框架中并未提供一个比较简洁的LRU算法，<code>NSCache</code>没怎么看懂，java中有<code>LruCache</code>。</p><h2 id="2-使用NSDictionary实现"><a href="#2-使用NSDictionary实现" class="headerlink" title="2 使用NSDictionary实现"></a>2 使用NSDictionary实现</h2><h3 id="2-1-实现代码"><a href="#2-1-实现代码" class="headerlink" title="2.1 实现代码"></a>2.1 实现代码</h3><p>为了便于查找，缓存通常都是<code>Dictionary</code>的形式，这里也是通过继承<code>NSMutableDictionary</code>来实现一个包含LRU算法的容器。</p><p>头文件如下，支持泛型：</p><figure class="highlight objc"><figcaption><span>LRUMutableDictionary.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LRUMutableDictionary</span>&lt;<span class="title">__covariant</span> <span class="title">KeyType</span>, <span class="title">__covariant</span> <span class="title">ObjectType</span>&gt; : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// maxCountLRU: 执行LRU算法时的最大存储的元素数量</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithMaxCountLRU:(<span class="built_in">NSUInteger</span>)maxCountLRU;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*****NSDictionary</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> count;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSEnumerator</span>&lt;KeyType&gt; *)keyEnumerator;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)enumerateKeysAndObjectsUsingBlock:(<span class="keyword">void</span> (^)(KeyType key, ObjectType obj, <span class="built_in">BOOL</span> *stop))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*****NSMutableDictionary</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(KeyType)aKey;</span><br><span class="line">- (<span class="keyword">void</span>)setObject:(ObjectType)anObject forKey:(KeyType &lt;<span class="built_in">NSCopying</span>&gt;)aKey;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjects;</span><br><span class="line">- (<span class="keyword">void</span>)removeObjectsForKeys:(<span class="built_in">NSArray</span>&lt;KeyType&gt; *)keyArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*****LRUMutableDictionary</span></span><br><span class="line"><span class="comment">// 执行LRU算法，当访问的元素可能是被淘汰的时候，可以通过在block中返回需要访问的对象，会根据LRU机制自动添加到dictionary中</span></span><br><span class="line">- (ObjectType)objectForKey:(KeyType)aKey returnEliminateObjectUsingBlock:(ObjectType (^)(<span class="built_in">BOOL</span> maybeEliminate))block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>实现文件如下：</p><figure class="highlight objc"><figcaption><span>LRUMutableDictionary.m</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"LRUMutableDictionary.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LRUMutableDictionary</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *dict;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *arrayForLRU;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> maxCountLRU;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LRUMutableDictionary</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithMaxCountLRU:(<span class="built_in">NSUInteger</span>)maxCountLRU</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _dict = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:maxCountLRU];</span><br><span class="line">        _arrayForLRU = [[<span class="built_in">NSMutableArray</span> alloc] initWithCapacity:maxCountLRU];</span><br><span class="line">        _maxCountLRU = maxCountLRU;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#pragma mark - NSDictionary</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)count</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [_dict count];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSEnumerator</span> *)keyEnumerator</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [_dict keyEnumerator];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)aKey</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> objectForKey:aKey returnEliminateObjectUsingBlock:^<span class="keyword">id</span>(<span class="built_in">BOOL</span> maybeEliminate) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)enumerateKeysAndObjectsUsingBlock:(<span class="keyword">void</span> (^)(<span class="keyword">id</span>, <span class="keyword">id</span>, <span class="built_in">BOOL</span> *))block</span><br><span class="line">&#123;</span><br><span class="line">    [_dict enumerateKeysAndObjectsUsingBlock:block];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSMutableDictionary</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>)aKey</span><br><span class="line">&#123;</span><br><span class="line">    [_dict removeObjectForKey:aKey];</span><br><span class="line">    [<span class="keyword">self</span> _removeObjectLRU:aKey];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)anObject forKey:(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;)aKey</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> isExist = ([_dict objectForKey:aKey] != <span class="literal">nil</span>);</span><br><span class="line">    [_dict setObject:anObject forKey:aKey];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isExist) &#123;</span><br><span class="line">        [<span class="keyword">self</span> _adjustPositionLRU:aKey];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> _addObjectLRU:aKey];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjects</span><br><span class="line">&#123;</span><br><span class="line">    [_dict removeAllObjects];</span><br><span class="line">    [_arrayForLRU removeAllObjects];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectsForKeys:(<span class="built_in">NSArray</span> *)keyArray</span><br><span class="line">&#123;</span><br><span class="line">    [_dict removeObjectsForKeys:keyArray];</span><br><span class="line">    [_arrayForLRU removeObjectsInArray:keyArray];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - LRUMutableDictionary</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)aKey returnEliminateObjectUsingBlock:(<span class="keyword">id</span> (^)(<span class="built_in">BOOL</span>))block</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> object = [_dict objectForKey:aKey];</span><br><span class="line">    <span class="keyword">if</span> (object) &#123;</span><br><span class="line">        [<span class="keyword">self</span> _adjustPositionLRU:aKey];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (block) &#123;</span><br><span class="line">        <span class="built_in">BOOL</span> maybeEliminate = object ? <span class="literal">NO</span> : <span class="literal">YES</span>;</span><br><span class="line">        <span class="keyword">id</span> newObject = block(maybeEliminate);</span><br><span class="line">        <span class="keyword">if</span> (newObject) &#123;</span><br><span class="line">            [<span class="keyword">self</span> setObject:newObject forKey:aKey];</span><br><span class="line">            <span class="keyword">return</span> [_dict objectForKey:aKey];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - LRU</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_adjustPositionLRU:(<span class="keyword">id</span>)anObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> idx = [_arrayForLRU indexOfObject:anObject];</span><br><span class="line">    <span class="keyword">if</span> (idx != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">        [_arrayForLRU removeObjectAtIndex:idx];</span><br><span class="line">        [_arrayForLRU insertObject:anObject atIndex:<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_addObjectLRU:(<span class="keyword">id</span>)anObject</span><br><span class="line">&#123;</span><br><span class="line">    [_arrayForLRU insertObject:anObject atIndex:<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 当超出LRU算法限制之后，将最不常使用的元素淘汰</span></span><br><span class="line">    <span class="keyword">if</span> ((_maxCountLRU &gt; <span class="number">0</span>) &amp;&amp; (_arrayForLRU.count &gt; _maxCountLRU)) &#123;</span><br><span class="line">        [_dict removeObjectForKey:[_arrayForLRU lastObject]];</span><br><span class="line">        [_arrayForLRU removeLastObject];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 【注意】这里不要直接调用下面这个方法，因为内部调用[_arrayForLRU removeObject:anObject];的时候，</span></span><br><span class="line">        <span class="comment">// 每次都将Array从头开始遍历到最后一个，这里既然已经知道是删除最后一个了，直接删除即可。</span></span><br><span class="line">        <span class="comment">// 使用下面这种方法会增加上百倍的耗时。</span></span><br><span class="line">        <span class="comment">// [self removeObjectForKey:[_arrayForLRU lastObject]];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_removeObjectLRU:(<span class="keyword">id</span>)anObject</span><br><span class="line">&#123;</span><br><span class="line">    [_arrayForLRU removeObject:anObject];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="2-2-实现原理概述"><a href="#2-2-实现原理概述" class="headerlink" title="2.2 实现原理概述"></a>2.2 实现原理概述</h3><ul><li>实现原理其实很简单，重写<code>NSMutableDictionary</code>的几个重要方法，内部持有<code>NSMutableDictionary</code>用于存储缓存数据。持有<code>NSMutableArray</code>用于存储<code>Key</code>值，<code>Key</code>的顺序为LRU算法中的优先级，最前面的元素表示最近使用，最后面的元素表示最近最少使用。</li><li>每次对<code>NSMutableDictionary</code>中的元素做数据操作，都认为这个元素是最近使用的元素，然后调整该元素的<code>Key</code>在<code>NSMutableArray</code>中的顺序为第一位。</li><li>设定一个容器可存储的数量最大值，当插入元素到超出这个最大值之后，在<code>NSMutableArray</code>中找到最后一个元素<code>Key</code>删除，并在<code>NSMutableDictionary</code>中找到对应的元素删除。</li></ul><h3 id="2-3-弊端"><a href="#2-3-弊端" class="headerlink" title="2.3 弊端"></a>2.3 弊端</h3><ol><li>以上的实现在对性能要求不是特别高的时候，已经可以满足需求了。</li><li>我们知道，<code>NSMutableArray</code>的内部是使用动态数组实现的，动态数组的缺点在这里被完全暴露出来，我们的实现里面基本上都在用到“插入”和“删除”的操作，这两个操作对动态数组的性能消耗是比较大的，比较好的实现方式应该是使用<strong>“双向链表”</strong>，奈何<code>Foundation</code>框架中没有我们想要的“双向链表”容器。当然我们可以使用C++的STL库中的<code>list</code>来实现，有兴趣的读者可以尝试。</li><li>容器中有设定一个容器的最大存储容量值，我相信，在使用这个LRU容器时，绝大部分的情况下都是达不到这个最大容量的，淘汰算法应该是属于一种保护措施不是吗？那么问题来了，如果大部分情况下都达不到最大容量，或者可能永远都达不到最大容量，那我们每次对元素操作时做了LRU算法调整，不是白费功夫吗（这个调整还是要消耗一些性能的），毕竟这个调整最终是为了当超出容量时用来将最后面的元素淘汰而做的准备，想想是不是可以以此做一些优化？</li></ol><h3 id="3-性能优化"><a href="#3-性能优化" class="headerlink" title="3 性能优化"></a>3 性能优化</h3><p>针对第三点弊端做一些优化，当容量达不到最大容量值得时候，可以完全停止掉LRU算法，这时候这个LRU容器就跟普通的<code>NSMutableDictionary</code>容器没什么两样了，当容量接近最大容量值得时候，开始启动LRU算法。</p><p>头文件不变，来看实现文件：</p><figure class="highlight objc"><figcaption><span>LRUMutableDictionary.m</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"LRUMutableDictionary.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个开始准备启动LRU的值，当 (MaxCount - CurCount &lt; LRU_RISK_COUNT) 时才启动 LRU</span></span><br><span class="line"><span class="meta">#define LRU_RISK_COUNT 100</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LRUMutableDictionary</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *dict;    <span class="comment">// 存储数据的字典</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *arrayForLRU;  <span class="comment">// 存放LRU的数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> maxCountLRU;       <span class="comment">// 最大存储值，存储量超出这个值，启动LRU淘汰算法</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isOpenLRU;               <span class="comment">// 是否开启LRU算法，如果存储量远低于最大存储值时，其实没有必要开启LRU算法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LRUMutableDictionary</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithMaxCountLRU:(<span class="built_in">NSUInteger</span>)maxCountLRU</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _dict = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:maxCountLRU];</span><br><span class="line">        _arrayForLRU = [[<span class="built_in">NSMutableArray</span> alloc] initWithCapacity:maxCountLRU];</span><br><span class="line">        _maxCountLRU = maxCountLRU;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#pragma mark - NSDictionary</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)count</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [_dict count];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSEnumerator</span> *)keyEnumerator</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [_dict keyEnumerator];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)aKey</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> objectForKey:aKey returnEliminateObjectUsingBlock:^<span class="keyword">id</span>(<span class="built_in">BOOL</span> maybeEliminate) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)enumerateKeysAndObjectsUsingBlock:(<span class="keyword">void</span> (^)(<span class="keyword">id</span>, <span class="keyword">id</span>, <span class="built_in">BOOL</span> *))block</span><br><span class="line">&#123;</span><br><span class="line">    [_dict enumerateKeysAndObjectsUsingBlock:block];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSMutableDictionary</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>)aKey</span><br><span class="line">&#123;</span><br><span class="line">    [_dict removeObjectForKey:aKey];</span><br><span class="line">    [<span class="keyword">self</span> _removeObjectLRU:aKey];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)anObject forKey:(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;)aKey</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> isExist = ([_dict objectForKey:aKey] != <span class="literal">nil</span>);</span><br><span class="line">    [_dict setObject:anObject forKey:aKey];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isExist) &#123;</span><br><span class="line">        [<span class="keyword">self</span> _adjustPositionLRU:aKey];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> _addObjectLRU:aKey];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjects</span><br><span class="line">&#123;</span><br><span class="line">    [_dict removeAllObjects];</span><br><span class="line">    [<span class="keyword">self</span> _removeAllObjectsLRU];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectsForKeys:(<span class="built_in">NSArray</span> *)keyArray</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (keyArray.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        [_dict removeObjectsForKeys:keyArray];</span><br><span class="line">        [<span class="keyword">self</span> _removeObjectsLRU:keyArray];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - LRUMutableDictionary</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)aKey returnEliminateObjectUsingBlock:(<span class="keyword">id</span> (^)(<span class="built_in">BOOL</span>))block</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> object = [_dict objectForKey:aKey];</span><br><span class="line">    <span class="keyword">if</span> (object) &#123;</span><br><span class="line">        [<span class="keyword">self</span> _adjustPositionLRU:aKey];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (block) &#123;</span><br><span class="line">        <span class="built_in">BOOL</span> maybeEliminate = object ? <span class="literal">NO</span> : <span class="literal">YES</span>;</span><br><span class="line">        <span class="keyword">id</span> newObject = block(maybeEliminate);</span><br><span class="line">        <span class="keyword">if</span> (newObject) &#123;</span><br><span class="line">            [<span class="keyword">self</span> setObject:newObject forKey:aKey];</span><br><span class="line">            <span class="keyword">return</span> [_dict objectForKey:aKey];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - LRU</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_adjustPositionLRU:(<span class="keyword">id</span>)anObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_isOpenLRU) &#123;</span><br><span class="line">        <span class="built_in">NSUInteger</span> idx = [_arrayForLRU indexOfObject:anObject];</span><br><span class="line">        <span class="keyword">if</span> (idx != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">            [_arrayForLRU removeObjectAtIndex:idx];</span><br><span class="line">            [_arrayForLRU insertObject:anObject atIndex:<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_addObjectLRU:(<span class="keyword">id</span>)anObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_isOpenLRU &amp;&amp; [<span class="keyword">self</span> isNeedOpenLRU:_dict.count]) &#123;</span><br><span class="line">        <span class="comment">// 如果原来没有开启 LRU，现在增加一个元素之后达到了存储量临界条件，则开启，一次性将所有的Key导入</span></span><br><span class="line">        [_arrayForLRU removeAllObjects];</span><br><span class="line">        [_arrayForLRU addObjectsFromArray:_dict.allKeys];</span><br><span class="line">        [_arrayForLRU removeObject:anObject];</span><br><span class="line">        _isOpenLRU = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_isOpenLRU) &#123;</span><br><span class="line">        [_arrayForLRU insertObject:anObject atIndex:<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 当超出LRU算法限制之后，将最不常使用的元素淘汰</span></span><br><span class="line">        <span class="keyword">if</span> ((_maxCountLRU &gt; <span class="number">0</span>) &amp;&amp; (_arrayForLRU.count &gt; _maxCountLRU)) &#123;</span><br><span class="line">            [_dict removeObjectForKey:[_arrayForLRU lastObject]];</span><br><span class="line">            [_arrayForLRU removeLastObject];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 【注意】这里不要直接调用下面这个方法，因为内部调用[_arrayForLRU removeObject:anObject];的时候，</span></span><br><span class="line">            <span class="comment">// 每次都将Array从头开始遍历到最后一个，这里既然已经知道是删除最后一个了，直接删除即可。</span></span><br><span class="line">            <span class="comment">// 使用下面这种方法会增加上百倍的耗时。</span></span><br><span class="line">            <span class="comment">// [self removeObjectForKey:[_arrayForLRU lastObject]];</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_removeObjectLRU:(<span class="keyword">id</span>)anObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_isOpenLRU) &#123;</span><br><span class="line">        [_arrayForLRU removeObject:anObject];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span> isNeedOpenLRU:_arrayForLRU.count]) &#123;</span><br><span class="line">            [_arrayForLRU removeAllObjects];</span><br><span class="line">            _isOpenLRU = <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_removeObjectsLRU:(<span class="built_in">NSArray</span> *)otherArray</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_isOpenLRU) &#123;</span><br><span class="line">        [_arrayForLRU removeObjectsInArray:otherArray];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span> isNeedOpenLRU:_arrayForLRU.count]) &#123;</span><br><span class="line">            [_arrayForLRU removeAllObjects];</span><br><span class="line">            _isOpenLRU = <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_removeAllObjectsLRU</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_isOpenLRU) &#123;</span><br><span class="line">        [_arrayForLRU removeAllObjects];</span><br><span class="line">        _isOpenLRU = <span class="literal">NO</span>;    <span class="comment">// 清空全部元素了，一定可以关闭LRU</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isNeedOpenLRU:(<span class="built_in">NSUInteger</span>)count</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (_maxCountLRU - count) &lt; LRU_RISK_COUNT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>上面定义 100 接近值可以根据实际情况做一些修改，以上实现方法已经在项目中实际使用，可以很好的满足需求。读者如果对于实现LRU算法有更好的方法，欢迎讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-LRU算法&quot;&gt;&lt;a href=&quot;#1-LRU算法&quot; class=&quot;headerlink&quot; title=&quot;1 LRU算法&quot;&gt;&lt;/a&gt;1 LRU算法&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;LRU（Least recently used，最近最少使用）&lt;/strong&gt;算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://vinnyxiong.cn/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="LRU算法" scheme="http://vinnyxiong.cn/tags/LRU%E7%AE%97%E6%B3%95/"/>
    
      <category term="NSDictionary容器" scheme="http://vinnyxiong.cn/tags/NSDictionary%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>在Xcode中为main函数设置输入参数</title>
    <link href="http://vinnyxiong.cn//blog/%E5%9C%A8Xcode%E4%B8%AD%E4%B8%BAmain%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0.html"/>
    <id>http://vinnyxiong.cn//blog/在Xcode中为main函数设置输入参数.html</id>
    <published>2016-03-24T14:28:26.000Z</published>
    <updated>2016-03-29T01:15:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-C-Object-C中的main函数参数"><a href="#1-C-Object-C中的main函数参数" class="headerlink" title="1.C++/Object-C中的main函数参数"></a>1.C++/Object-C中的main函数参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        printf(&quot;Hello, World! argc=%d\n&quot;, argc);</span><br><span class="line">        for (int i = 0; i &lt; argc; i++) &#123;</span><br><span class="line">            printf(&quot;%s\n&quot;, argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚开始学C/C++语言的时候通常写main函数时，参数会写为空的形式<code>int main()</code>，但是实际上main函数是可以有参数的。如果把这个程序编译成可执行文件之后，可以在命令行中执行(假设程序名为<code>calc</code>)，并且输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./calc aaa bbb ccc</span><br><span class="line">Hello, World! argc=4</span><br><span class="line">./calc</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int argc // 表示后面的数组的元素个数</span><br><span class="line">const char * argv[] // 表示输入的参数，需要注意的是，程序名称也是参数之一，并且一定是第一个</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-在Xcode中为main函数添加调试参数"><a href="#2-在Xcode中为main函数添加调试参数" class="headerlink" title="2.在Xcode中为main函数添加调试参数"></a>2.在Xcode中为main函数添加调试参数</h2><p>如果希望在调试代码的时候，也能为main函数添加参数，需要在Xcode中进行设置，方法如下：</p><p>1.首先从菜单打开<code>Product-Scheme-Edit Scheme...</code>。</p><img src="/images/blog_post_images/2016-03/2016-03-24-在Xcode中为main函数设置输入参数1.jpg"><p>2.在<code>Arguments</code>中添加参数，如上图所示。<br>3.再在Xcode中调试运行，即可在Output中输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Hello, World! argc=4</span><br><span class="line">/Users/username/Library/Developer/Xcode/DerivedData/Calculator-bahlkbpokkgpyuadshgqwpythbvb/Build/Products/Debug/calc</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-C-Object-C中的main函数参数&quot;&gt;&lt;a href=&quot;#1-C-Object-C中的main函数参数&quot; class=&quot;headerlink&quot; title=&quot;1.C++/Object-C中的main函数参数&quot;&gt;&lt;/a&gt;1.C++/Object-C中的main函数参数&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int main(int argc, const char * argv[]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @autoreleasepool &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        printf(&amp;quot;Hello, World! argc=%d\n&amp;quot;, argc);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for (int i = 0; i &amp;lt; argc; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            printf(&amp;quot;%s\n&amp;quot;, argv[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;刚开始学C/C++语言的时候通常写main函数时，参数会写为空的形式&lt;code&gt;int main()&lt;/code&gt;，但是实际上main函数是可以有参数的。如果把这个程序编译成可执行文件之后，可以在命令行中执行(假设程序名为&lt;code&gt;calc&lt;/code&gt;)，并且输出如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ ./calc aaa bbb ccc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Hello, World! argc=4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;./calc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;aaa&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bbb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ccc&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int argc // 表示后面的数组的元素个数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const char * argv[] // 表示输入的参数，需要注意的是，程序名称也是参数之一，并且一定是第一个&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Object-C" scheme="http://vinnyxiong.cn/categories/Object-C/"/>
    
    
      <category term="Object-C" scheme="http://vinnyxiong.cn/tags/Object-C/"/>
    
      <category term="Xcode" scheme="http://vinnyxiong.cn/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>Hexo之旅(三)：Hexo博客个性化及NexT主题配置</title>
    <link href="http://vinnyxiong.cn//blog/Hexo%E4%B9%8B%E6%97%85-%E4%B8%89-%EF%BC%9AHexo%E5%8D%9A%E5%AE%A2%E4%B8%AA%E6%80%A7%E5%8C%96%E5%8F%8ANexT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE.html"/>
    <id>http://vinnyxiong.cn//blog/Hexo之旅-三-：Hexo博客个性化及NexT主题配置.html</id>
    <published>2016-03-03T01:24:01.000Z</published>
    <updated>2017-07-11T11:52:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Hexo-博客主题的选择"><a href="#1-Hexo-博客主题的选择" class="headerlink" title="1 Hexo 博客主题的选择"></a>1 Hexo 博客主题的选择</h2><p>为什么先选主题呢？因为不同的主题会有不同的风格，配合主题风格来去个性化我们的博客，比如博客标题、博客介绍、网站图标等，可以让这些更加匹配主题风格。况且一旦选定了一个主题，这就是你的博客的风格了，不会随意改变。所以首先选定一个主题是个性化的第一步。<br>如果你有一定的编程知识，又喜欢自己折腾，那么你自己写一款主题或者在别人的主题之上做修改，也是一件很Geek的事情。<br>如果你只想用现成的主题，那就选一款吧。Hexo 官网收录了几十款主题，地址在这里：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a>。<br>知乎上对一些主题的评价：<a href="http://www.zhihu.com/question/24422335" target="_blank" rel="noopener">有哪些好看的 Hexo 主题？</a>。<br>我的博客也正是这样，选择了评价最高的 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener"><strong>NexT</strong></a> 主题。<br>你呢？如果你跟我一样，选择了 NexT 主题，那么跟着我一起做个性化配置吧，当然，别的主题的配置也大体相同的。<br><a id="more"></a></p><h2 id="2-新主题安装"><a href="#2-新主题安装" class="headerlink" title="2 新主题安装"></a>2 新主题安装</h2><p>NexT 主题提供了详细的 <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">使用文档</a> 。</p><h3 id="2-1-下载-NexT-主题"><a href="#2-1-下载-NexT-主题" class="headerlink" title="2.1 下载 NexT 主题"></a>2.1 下载 NexT 主题</h3><p>主题的安装很简单，执行以下命令即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd your-hexo-site</span><br><span class="line">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p><h3 id="2-2-启用-NexT-主题"><a href="#2-2-启用-NexT-主题" class="headerlink" title="2.2 启用 NexT 主题"></a>2.2 启用 NexT 主题</h3><p>克隆/下载 完成后，打开 站点配置文件，找到<code>theme</code>字段，并将其值更改为<code>next</code>。</p><blockquote><p>这里注意区分两个配置文件：<br>站点配置文件：是你的 hexo 博客目录下面的 _config.yml 文件。<br>主题配置文件：是 themes/next 目录下的 _config.yml 文件。</p></blockquote><h3 id="2-3-验证主题是否启用"><a href="#2-3-验证主题是否启用" class="headerlink" title="2.3 验证主题是否启用"></a>2.3 验证主题是否启用</h3><p>运行<code>hexo s --debug</code>，并访问<code>http://localhost:4000</code>，确保站点正确运行。</p><h2 id="3-博客基本配置"><a href="#3-博客基本配置" class="headerlink" title="3 博客基本配置"></a>3 博客基本配置</h2><h3 id="3-1-语言设置"><a href="#3-1-语言设置" class="headerlink" title="3.1 语言设置"></a>3.1 语言设置</h3><p>每个主题都会配置几种界面显示语言，修改语言只要编辑 站点配置文件，将 language 设置成你所需要的语言。<br>例如选用简体中文，则配置为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language: zh-Hans</span><br></pre></td></tr></table></figure></p><p>查看主题支持哪些语言可以看 <code>themes/next/languages</code> 目录下有哪些语言文件。</p><h3 id="3-2-网站标题，作者"><a href="#3-2-网站标题，作者" class="headerlink" title="3.2 网站标题，作者"></a>3.2 网站标题，作者</h3><p>打开 站点配置文件 ，修改这些值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: Hexo #博客标题</span><br><span class="line">subtitle: #博客副标题</span><br><span class="line">description: #博客描述</span><br><span class="line">author: #博客描述</span><br></pre></td></tr></table></figure><blockquote><p>注意：配置文件要符合英文标点符号使用规范: 冒号后必须空格，否则会编译错误</p></blockquote><h3 id="3-3-域名，文章链接"><a href="#3-3-域名，文章链接" class="headerlink" title="3.3 域名，文章链接"></a>3.3 域名，文章链接</h3><p>打开 站点配置文件 ，修改这些值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url: http://xxx #你的博客网址</span><br><span class="line">root: /#博客跟目录，如果你的博客在网址的二级目录下，在这里填上</span><br><span class="line">permalink: /blog/:title.html #:year/:month/:day/:title/ 原来跟着年月日，建议缩短为一个 blog目录加标题，以后取文章标题的时候不要重复就可以。</span><br><span class="line">permalink_defaults: #可以不填</span><br></pre></td></tr></table></figure></p><h3 id="3-4-NexT-主题-Scheme-设置"><a href="#3-4-NexT-主题-Scheme-设置" class="headerlink" title="3.4 NexT 主题 Scheme 设置"></a>3.4 NexT 主题 Scheme 设置</h3><p>NexT 主题目前提供了3中风格类似，但是又有点不同的主题风格，可以通过修改 主题配置文件 中的 Scheme 值来启用其中一种风格，例如我的博客用的是 Pisces 分栏风格，只要把另外两个用<code>#</code>注释掉即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">scheme: Pisces</span><br></pre></td></tr></table></figure></p><h3 id="3-5-更多基本配置参考"><a href="#3-5-更多基本配置参考" class="headerlink" title="3.5 更多基本配置参考"></a>3.5 更多基本配置参考</h3><p>其实还有更多的博客及主题的设置，可以直接参考 <a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo官方文档</a> 和 <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT主题文档</a> ,他们都是中文的。</p><p>NexT 在 Github 上的问题反馈和解决交流很多。<a href="https://github.com/iissnan/hexo-theme-next/issues" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next/issues</a> 。如果你在配置博客过程中遇到什么问题，可以在我的博客评论中提问，或者直接到 Github 上提问都可以。</p><p>看 Github 的 Fork 的人数，截止到今天(2016.03.03)。<a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">Hexo博客</a> 的 Fork 数是 1445 ，而 <a href="https://github.com/iissnan/hexo-theme-next/issues" target="_blank" rel="noopener">Next主题</a> 的 Fork 数都达到了 917 。说明这款主题受欢迎的程度之高。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Hexo-博客主题的选择&quot;&gt;&lt;a href=&quot;#1-Hexo-博客主题的选择&quot; class=&quot;headerlink&quot; title=&quot;1 Hexo 博客主题的选择&quot;&gt;&lt;/a&gt;1 Hexo 博客主题的选择&lt;/h2&gt;&lt;p&gt;为什么先选主题呢？因为不同的主题会有不同的风格，配合主题风格来去个性化我们的博客，比如博客标题、博客介绍、网站图标等，可以让这些更加匹配主题风格。况且一旦选定了一个主题，这就是你的博客的风格了，不会随意改变。所以首先选定一个主题是个性化的第一步。&lt;br&gt;如果你有一定的编程知识，又喜欢自己折腾，那么你自己写一款主题或者在别人的主题之上做修改，也是一件很Geek的事情。&lt;br&gt;如果你只想用现成的主题，那就选一款吧。Hexo 官网收录了几十款主题，地址在这里：&lt;a href=&quot;https://hexo.io/themes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://hexo.io/themes/&lt;/a&gt;。&lt;br&gt;知乎上对一些主题的评价：&lt;a href=&quot;http://www.zhihu.com/question/24422335&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;有哪些好看的 Hexo 主题？&lt;/a&gt;。&lt;br&gt;我的博客也正是这样，选择了评价最高的 &lt;a href=&quot;https://github.com/iissnan/hexo-theme-next&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;NexT&lt;/strong&gt;&lt;/a&gt; 主题。&lt;br&gt;你呢？如果你跟我一样，选择了 NexT 主题，那么跟着我一起做个性化配置吧，当然，别的主题的配置也大体相同的。&lt;br&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://vinnyxiong.cn/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://vinnyxiong.cn/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo之旅(二)：Hexo博客搭建(在 Mac OS 平台)</title>
    <link href="http://vinnyxiong.cn//blog/Hexo%E4%B9%8B%E6%97%85-%E4%BA%8C-%EF%BC%9AHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA-%E5%9C%A8%20Mac%20OS%20%E5%B9%B3%E5%8F%B0-.html"/>
    <id>http://vinnyxiong.cn//blog/Hexo之旅-二-：Hexo博客搭建-在 Mac OS 平台-.html</id>
    <published>2016-03-01T02:54:02.000Z</published>
    <updated>2016-04-05T15:52:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Git-Pages-服务准备"><a href="#1-Git-Pages-服务准备" class="headerlink" title="1 Git Pages 服务准备"></a>1 Git Pages 服务准备</h2><blockquote><p>工欲善其事，必先利其器。</p></blockquote><p>在配置本地环境之前，先介绍Pages服务，是因为这是一切静态博客的基础。我们之所以能够使用Github、GitCafe等代码托管站来托管我们的博客，是因为他们提供了<strong>Pages</strong>服务。来看GitCafe上的介绍。<br><blockquote><p>GitCafe Pages 是一项公众网页托管和发布服务。你可以使用 GitCafe Pages 托管博客、项目官网一类的静态网页，支持绑定自定义域名。<br>GitCafe Pages 支持用户 Pages 服务和项目 Pages 服务。用户 Pages 可以通过 user_name.gitcafe.io 形式的 URL 直接访问，适合用作个人或组织的静态博客或网站；项目 Pages 需通过user_name.gitcafe.io/project_name形式的 URL 访问，更适合托管项目的官网或博客。</p><footer><strong>Pages服务</strong><cite><a href="https://help.gitcafe.com/manuals/help/pages-services" target="_blank" rel="noopener">help.gitcafe.com/manuals/help/pages-services</a></cite></footer></blockquote></p><h3 id="1-1-创建Github项目"><a href="#1-1-创建Github项目" class="headerlink" title="1.1 创建Github项目"></a>1.1 创建Github项目</h3><p>这里只以Github为例，GitCafe是类似的。<br>如果还没有Github账号，先去注册一个吧<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a>。<br>用刚刚注册的 Github 账号登录，然后在点击页面右上角的加号，在弹出菜单中点击<code>New Repository</code>，如图所示<a id="more"></a><br><img src="/images/blog_post_images/2016-03/2016-03-01-Hexo之旅-二-：Hexo博客搭建1.jpg"><br>然后会跳转到一个新建库(Create new repository)的页面，在<code>Repository name</code>一栏填<code>[your_username].github.io</code>，<code>[your_username]</code>是你 Github 上的用户名，请务必按照此格式填写，否则无法在 Github 上部署博客。然后点击 Create repository 按钮提交。<br>如果一切顺利会出现一个页面，有一个 SSH 地址，形如<code>git@github.com:[your_username]/[your_username].github.io.git</code>，下一步会用到。（这里会有两种形式的地址，一种是HTTPS的，一种是SSH的，我们用SSH形式的）。</p><h3 id="1-2-添加-SSH-公钥"><a href="#1-2-添加-SSH-公钥" class="headerlink" title="1.2 添加 SSH 公钥"></a>1.2 添加 SSH 公钥</h3><p>为了保证安全，以及不用每次输入git密码，我们可以在Github上添加 SSH 公钥。<br>SSH 密钥的创建需要在终端（命令行）环境下进行，我们首先进入命令行环境。通常在 Mac OS X 和 Linux 平台下我们使用终端工具（Terminal），在 Windows 平台中，可以使用 Git Bash 工具。<br>在 GitCafe 的官网上有很详细的添加 SSH 公钥的方法的介绍。<br><a href="https://help.gitcafe.com/manuals/help/ssh-key" target="_blank" rel="noopener"><strong>点击查看“添加 SSH 公钥”的方法</strong></a><br><em>注意：</em>如果是同一个Email注册的Github和GitCafe，在本地只需要生成一次公钥密钥，然后分别添加到Github和GitCafe上。<br>添加到Github上的方法与GitCafe是类似的，点击右上角的头像打开<code>setting</code>，点击<code>SSH Keys</code>，点击右上角的<code>New SSH key</code>，将公钥复制进去创建即可。<br><img src="/images/blog_post_images/2016-03/2016-03-01-Hexo之旅-二-：Hexo博客搭建2.jpg"></p><p>做完上面这两个步骤，我们的 Pages 服务就准备好了，下面开始搭建本地环境。</p><h2 id="2-本地环境准备"><a href="#2-本地环境准备" class="headerlink" title="2 本地环境准备"></a>2 本地环境准备</h2><p>既然是为黑客设计的博客框架，安装起来肯定没有像普通应用程序那么简单，需要一些准备工作，但请相信我，并不复杂。</p><ol><li>Hexo 是基于 Node.js 的，而且我们需要使用 git 来管理代码，所以总体上来说我们需要安装 Node.js 和 Git。</li><li>安装 Node.js 和 Git 可以通过 HomeBrew 安装。</li></ol><h3 id="2-1-安装-HomeBrew"><a href="#2-1-安装-HomeBrew" class="headerlink" title="2.1 安装 HomeBrew"></a>2.1 安装 HomeBrew</h3><p>HomeBrew 是一个非常有用的软件包管理系统，你可以把它想象成一个稍微抽象一点的 Mac App Store。正如我们用 Mac App Store 来安装其他软件一样，我们这一步安装 HomeBrew 的目的是为了安装别的软件（Node.js 和 Git）。当然 Mac App Store 和 HomeBrew 本身也是软件。<br>安装 HomeBrew 非常简单，打开终端 (Terminal)，执行以下命令（所谓「执行」即「输入+回车」，下同）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><p>如果在执行上如命令的时候弹出需要安装 Xcode Command Line Tool 的提示，直接点击安装即可。<br>安装好之后最好先执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew doctor</span><br></pre></td></tr></table></figure><p>此条命令用来诊断安装中出现的问题并提示修复方法，如果没有问题则会显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ Your system is ready to brew.</span><br></pre></td></tr></table></figure><p>如遇问题，则按照提示处理，如果不懂如何处理可以先试着执行后面的步骤，如果能成功，则没有太大问题，毕竟我们只是想写博客而已。当然，做任何事情之前，备份是必须的。</p><h3 id="2-2-安装-Git"><a href="#2-2-安装-Git" class="headerlink" title="2.2 安装 Git"></a>2.2 安装 Git</h3><p>安装 Git 非常简单，执行以下命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install git</span><br></pre></td></tr></table></figure><h3 id="2-3-安装-Node-js"><a href="#2-3-安装-Node-js" class="headerlink" title="2.3 安装 Node.js"></a>2.3 安装 Node.js</h3><p>Hexo官网上说安装Node.js 的最佳方式是使用nvm。因此推荐的安装流程如下：</p><ol><li>使用Homebrew安裝nvm</li><li>使用nvm安裝Node.js</li><li>使用nvm无痛切换Node.js版本</li></ol><h4 id="使用Homebrew安裝nvm"><a href="#使用Homebrew安裝nvm" class="headerlink" title="使用Homebrew安裝nvm"></a>使用Homebrew安裝nvm</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install nvm</span><br></pre></td></tr></table></figure><p>安装过程看到如下提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">==&gt; Downloading https://github.com/creationix/nvm/archive/v0.30.1.tar.gz</span><br><span class="line">==&gt; Downloading from https://codeload.github.com/creationix/nvm/tar.gz/v0.30.1</span><br><span class="line">######################################################################## 100.0%</span><br><span class="line">==&gt; Caveats</span><br><span class="line">Please note that upstream has asked us to make explicit managing</span><br><span class="line">nvm via Homebrew is unsupported by them and you should check any</span><br><span class="line">problems against the standard nvm install method prior to reporting.</span><br><span class="line"></span><br><span class="line">You should create NVM&apos;s working directory if it doesn&apos;t exist:</span><br><span class="line"></span><br><span class="line">  mkdir ~/.nvm</span><br><span class="line"></span><br><span class="line">Add the following to ~/.bash_profile or your desired shell</span><br><span class="line">configuration file:</span><br><span class="line"></span><br><span class="line">  export NVM_DIR=~/.nvm</span><br><span class="line">  . $(brew --prefix nvm)/nvm.sh</span><br><span class="line"></span><br><span class="line">You can set $NVM_DIR to any location, but leaving it unchanged from</span><br><span class="line">/usr/local/Cellar/nvm/0.30.1 will destroy any nvm-installed Node installations</span><br><span class="line">upon upgrade/reinstall.</span><br><span class="line"></span><br><span class="line">Type `nvm help` for further information.</span><br><span class="line"></span><br><span class="line">Bash completion has been installed to:</span><br><span class="line">  /usr/local/etc/bash_completion.d</span><br><span class="line">==&gt; Summary</span><br><span class="line">🍺  /usr/local/Cellar/nvm/0.30.1: 6 files, 82.6K, built in 6 seconds</span><br></pre></td></tr></table></figure><p>根据提示知道，为了让你可以直接在shell使用nvm指令，必须创建nvm的工作目录，并且在你的 .bash_profile 加入以下两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export NVM_DIR=~/.nvm</span><br><span class="line">. $(brew --prefix nvm)/nvm.sh</span><br></pre></td></tr></table></figure><p>在终端按顺序执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/.nvm</span><br><span class="line">$ echo &quot;export NVM_DIR=~/.nvm&quot; &gt;&gt; .bash_profile</span><br><span class="line">$ echo &quot;. $(brew --prefix nvm)/nvm.sh&quot; &gt;&gt; .bash_profile</span><br></pre></td></tr></table></figure><p>记得重新source你的 .bash_profile来让设定生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ . ~/.bash_profile</span><br></pre></td></tr></table></figure><p>最后用 <code>nvm help</code> 来验证nvm是否正确安装</p><p><strong>以上步骤一定要执行，不然无法在命令行使用nvm。有时候你明明记得已经安装了nvm，但是提示找不到nvm命令，则可以重复执行以上的步骤。</strong></p><h4 id="使用nvm安裝Node-js"><a href="#使用nvm安裝Node-js" class="headerlink" title="使用nvm安裝Node.js"></a>使用nvm安裝Node.js</h4><p>安裝完了nvm，接著安裝主角 Node.js。先用 <code>$ nvm ls-remote</code> 指令看一下有哪些版本可以安裝：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ nvm ls-remote</span><br><span class="line">      .</span><br><span class="line">      .</span><br><span class="line">      .</span><br><span class="line">       v0.11.12</span><br><span class="line">       v0.11.13</span><br><span class="line">       v0.11.14</span><br><span class="line">       v0.11.15</span><br><span class="line">       v0.11.16</span><br><span class="line">        v0.12.0</span><br><span class="line">        v0.12.1</span><br><span class="line">        v0.12.2</span><br><span class="line">        v0.12.3</span><br><span class="line">        v0.12.4</span><br><span class="line">        v0.12.5</span><br><span class="line">        v0.12.6</span><br><span class="line">        v0.12.7</span><br><span class="line">        v0.12.8</span><br><span class="line">        v0.12.9</span><br><span class="line">        v0.12.10</span><br><span class="line">      .</span><br><span class="line">      .</span><br><span class="line">      .</span><br></pre></td></tr></table></figure><p>直接用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install &lt;version&gt;</span><br></pre></td></tr></table></figure><p>指令安装官网上建议的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install v0.12.10</span><br><span class="line">######################################################################## 100.0%</span><br><span class="line"></span><br><span class="line">Now using node v0.12.2</span><br></pre></td></tr></table></figure><h4 id="使用nvm无痛切换Node-js版本"><a href="#使用nvm无痛切换Node-js版本" class="headerlink" title="使用nvm无痛切换Node.js版本"></a>使用nvm无痛切换Node.js版本</h4><p>检查当前使用的 Node.js 版本使用命令 <code>nvm ls</code>。如果输出结果如下表示正确：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt;     v0.12.10</span><br><span class="line">         system</span><br><span class="line">default -&gt; v0.12.10</span><br><span class="line">node -&gt; stable (-&gt; v0.12.10) (default)</span><br><span class="line">stable -&gt; 0.12 (-&gt; v0.12.10) (default)</span><br><span class="line">iojs -&gt; N/A (default)</span><br></pre></td></tr></table></figure><p>第一个 <code>-&gt;</code> 表示当前使用的版本，<code>default -&gt;</code> 表示默认版本，必须保证这两个，不然后面安装hexo会提示 <code>-bash: hexo: command not found</code> ，不能在命令行使用。<br>设置的方法是，先通过 <code>nvm ls</code> 看看本地安装了什么版本，如果本地没有，则应该使用上一步的方法先安装，然后执行这个命令指定版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm use v0.12.10</span><br></pre></td></tr></table></figure><p>再通过这个命令指定默认版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm alias default v0.12.10</span><br></pre></td></tr></table></figure><h3 id="2-4-安装-Hexo"><a href="#2-4-安装-Hexo" class="headerlink" title="2.4 安装 Hexo"></a>2.4 安装 Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p><p>-g 或 –global 表示全局安装模块，如果没有这个参数，会安装在当前目录的node_modules子目录下。<br>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p><p><code>$ npm install</code> 表示安装当前目录package.json文件中配置的dependencies模块。</p><h3 id="2-5-更新-Hexo"><a href="#2-5-更新-Hexo" class="headerlink" title="2.5 更新 Hexo"></a>2.5 更新 Hexo</h3><p>官方发布了新版本后，可以在Hexo建立的博客目录内运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm update</span><br></pre></td></tr></table></figure></p><p>用如下命令可以检查package.json文件中配置的dependencies的版本号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm ls --depth=0</span><br></pre></td></tr></table></figure></p><h3 id="2-6-部署-Hexo"><a href="#2-6-部署-Hexo" class="headerlink" title="2.6 部署 Hexo"></a>2.6 部署 Hexo</h3><p>Hexo 3.0版本需要单独安装发布器插件，检查博客目录的node_modules中有没有<code>hexo-deployer-git</code>文件夹，若没有，执行以下命令安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>添加 -save 参数安装的模块的名字及其版本信息会出现在package.json的dependencies选项中。</p><p>另外，从Hexo 3.0开始配置文件<code>_config.yml</code>中的部署类型记得要填写成<code>git</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git ##部署类型，其它类型自行google之</span><br><span class="line">  repo: &lt;repository url&gt; ##git仓库地址</span><br><span class="line">  branch: [branch] ##git 页面分支</span><br><span class="line">  message: [message] ##git message建议默认字段update 可以自定义</span><br></pre></td></tr></table></figure></p><p>如果要同时部署到 Github 和 GitCafe 上，可以按照下面的方式来写，这时候就要用到前面创建 Github 项目时的 SSH 地址了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">    github: git@github.com:[your_username]/[your_username].github.io.git,master</span><br><span class="line">    gitcafe: git@gitcafe.com:[your_username]/[your_username].git,gitcafe-pages</span><br></pre></td></tr></table></figure></p><p>把<code>[your_username]</code>改成你的<code>username</code>即可，逗号后面跟着分支名，如果是<code>master</code>可以省略。</p><h3 id="2-7-运行-Hexo"><a href="#2-7-运行-Hexo" class="headerlink" title="2.7 运行 Hexo"></a>2.7 运行 Hexo</h3><p>到现在，一个 Hexo 博客已经搭建起来了，你可以在本地运行，也可以发布到 Git Page 服务商运行。<br>执行下面的命令就可以在本地运行一个 Hexo 博客了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server 或 hexo s</span><br></pre></td></tr></table></figure></p><p>这个命令执行之后 Hexo 会监视文件变动并自动更新，您无须重启服务器。<br>按照提示打开<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>即可。</p><p>当然我们最终还是要发布到 Github 或 GitCafe 上的，每次更新完博客发布需要执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean  # 清空</span><br><span class="line">$ hexo generate 或 hexo g# 生成</span><br><span class="line"># hexo deploy 或 hexo d# 发布</span><br></pre></td></tr></table></figure></p><p>然后在浏览器输入 <code>http://[your_username].github.io/</code>，如果是 GitCafe，则是 <code>http://[your_username].gitcafe.io/</code>，即可打开我们的博客了，里面有一篇默认的“Hello World”文章（果然任何程序都是从 Hello World 开始的啊）。</p><p>有人写了个各种命令的总结：<a href="http://jslite.io/2015/03/30/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">hexo常用命令笔记</a></p><h2 id="3-尾巴"><a href="#3-尾巴" class="headerlink" title="3 尾巴"></a>3 尾巴</h2><p>搭建一个 Hexo 博客还是很简单的，当然现在的运行起来的只是一个博客的默认的样子，我们需要更多的个性化，来把她真正地变成我们的个人博客。后面会再介绍博客的优化及个性化方法。<br><blockquote><p>俗话说，“好记性不如烂笔头”，写这篇文字也是为了记录自己的博客搭建过程，以及中间遇到的问题的处理和解决方法的记录，当然也可以当作是一个对于新手的教程吧。</p></blockquote></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Git-Pages-服务准备&quot;&gt;&lt;a href=&quot;#1-Git-Pages-服务准备&quot; class=&quot;headerlink&quot; title=&quot;1 Git Pages 服务准备&quot;&gt;&lt;/a&gt;1 Git Pages 服务准备&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;工欲善其事，必先利其器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在配置本地环境之前，先介绍Pages服务，是因为这是一切静态博客的基础。我们之所以能够使用Github、GitCafe等代码托管站来托管我们的博客，是因为他们提供了&lt;strong&gt;Pages&lt;/strong&gt;服务。来看GitCafe上的介绍。&lt;br&gt;&lt;blockquote&gt;&lt;p&gt;GitCafe Pages 是一项公众网页托管和发布服务。你可以使用 GitCafe Pages 托管博客、项目官网一类的静态网页，支持绑定自定义域名。&lt;br&gt;GitCafe Pages 支持用户 Pages 服务和项目 Pages 服务。用户 Pages 可以通过 user_name.gitcafe.io 形式的 URL 直接访问，适合用作个人或组织的静态博客或网站；项目 Pages 需通过user_name.gitcafe.io/project_name形式的 URL 访问，更适合托管项目的官网或博客。&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;Pages服务&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;https://help.gitcafe.com/manuals/help/pages-services&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;help.gitcafe.com/manuals/help/pages-services&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-1-创建Github项目&quot;&gt;&lt;a href=&quot;#1-1-创建Github项目&quot; class=&quot;headerlink&quot; title=&quot;1.1 创建Github项目&quot;&gt;&lt;/a&gt;1.1 创建Github项目&lt;/h3&gt;&lt;p&gt;这里只以Github为例，GitCafe是类似的。&lt;br&gt;如果还没有Github账号，先去注册一个吧&lt;a href=&quot;https://github.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/&lt;/a&gt;。&lt;br&gt;用刚刚注册的 Github 账号登录，然后在点击页面右上角的加号，在弹出菜单中点击&lt;code&gt;New Repository&lt;/code&gt;，如图所示
    
    </summary>
    
      <category term="Hexo" scheme="http://vinnyxiong.cn/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://vinnyxiong.cn/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo之旅(一)：Hexo我的博客</title>
    <link href="http://vinnyxiong.cn//blog/Hexo%E4%B9%8B%E6%97%85-%E4%B8%80-%EF%BC%9AHexo%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2.html"/>
    <id>http://vinnyxiong.cn//blog/Hexo之旅-一-：Hexo我的博客.html</id>
    <published>2016-02-25T04:46:19.000Z</published>
    <updated>2017-02-13T14:38:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-独立博客"><a href="#1-独立博客" class="headerlink" title="1 独立博客"></a>1 独立博客</h2><p><a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="noopener">阮一峰</a>大神说喜欢写Blog的人，会经历三个阶段。</p><blockquote><ul><li>第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。</li><li>第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。</li><li>第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</li></ul><footer><strong>阮一峰</strong><cite><a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="noopener">搭建一个免费的，无限流量的Blog----github Pages和Jekyll入门</a></cite></footer></blockquote><p>大多数Blog作者，都停留在第一和第二阶段，因为第三阶段不太容易到达：你很难找到俯首听命、愿意为你管理服务器的人。</p><p>但是现在Github和GitCafe等代码站都提供了Pages功能，只要将写好的文章提交到Github上托管，即可生成独立博客，而且提供几乎不限流量的存储空间，一切都是免费的。一旦搭建好，则只需要负责写文章就行了，不需要过多的管理。这不就是博客的第三阶段吗。</p><a id="more"></a><h2 id="2-Jekyll、Octopress、Hexo"><a href="#2-Jekyll、Octopress、Hexo" class="headerlink" title="2 Jekyll、Octopress、Hexo"></a>2 Jekyll、Octopress、Hexo</h2><p>现在可以搭建在Github上的静态博客生成器有Jekyll、Octopress、Hexo等。</p><blockquote><ol><li>Jekyll，没用过这个，看介绍感觉搭建比较麻烦，使用复杂，需要比较熟悉git的操作。</li><li>Octopress，在这之前用的就是Octopress，它基于Ruby的，所以生成博客文章的速度比较慢。搭建虽然很简单，但是想要自定义到自己想要的效果，配置过程还是有些复杂。</li><li>Hexo，正是现在使用的，它是基于Node.js的，速度非常快，搭建和配置比Octopress简单很多。</li></ol></blockquote><p>另外，对Octopress感兴趣的可以参考这些文章：</p><p> <a href="http://shengmingzhiqing.com/blog/setup-octopress-with-github-pages.html/" target="_blank" rel="noopener">Octopress 搭建流程 – Github Pages</a><br> <a href="http://shengmingzhiqing.com/blog/octopress-tutorials-toc.html/" target="_blank" rel="noopener">Octopress 教程目录</a><br> <a href="http://foggry.com/blog/2014/04/28/custom-your-octopress-blog/" target="_blank" rel="noopener">自定义你的Octopress博客</a><br> <a href="http://www.jianshu.com/p/0ac2ac1a8e45" target="_blank" rel="noopener">octopress博客搭建和个性化配置</a><br> <a href="http://foggry.com/blog/2014/04/02/ru-he-pei-zhi-rang-ni-de-octopressbo-ke-zai-duo-tai-macshang-tong-shi-shi-yong/" target="_blank" rel="noopener">让Octopress博客在多台Mac上同时使用</a></p><h2 id="3-Hexo之旅"><a href="#3-Hexo之旅" class="headerlink" title="3 Hexo之旅"></a>3 Hexo之旅</h2><p>在使用Octopress之时，对博客折腾了好久，做各种SEO优化等，总共也没写几篇文章。直到遇到搭配 <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT</a> 主题的 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 时，我感觉这正是我想要的个人博客的样子。正如我现在的<a href="http://vinnyxiong.github.io/" target="_blank" rel="noopener">博客</a>一样。</p><p>Hexo出自台湾大学生 <a href="http://twitter.com/tommy351" target="_blank" rel="noopener">tommy351</a> 之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。先看看tommy是如何吐槽Octopress的 →＿→ <a href="https://zespia.tw/blog/2012/10/11/hexo-debut/" target="_blank" rel="noopener">Hexo颯爽登場</a>。</p><ol><li>如果你对默认配置满意，只需几个命令便可秒搭一个hexo独立博客。</li><li>如果你跟我一样喜欢折腾一下，多花一点时间也可以搭出一个足够个性化的个人博客。</li><li>如果你过于喜欢折腾，并且对前端编程有点基础，可以尽情地玩，尽情地自定义属于自己的完美博客。</li></ol><p>后面几篇文章将一步一步介绍如果将博客做成现在这个样子。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-独立博客&quot;&gt;&lt;a href=&quot;#1-独立博客&quot; class=&quot;headerlink&quot; title=&quot;1 独立博客&quot;&gt;&lt;/a&gt;1 独立博客&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阮一峰&lt;/a&gt;大神说喜欢写Blog的人，会经历三个阶段。&lt;/p&gt;
&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。&lt;/li&gt;
&lt;li&gt;第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。&lt;/li&gt;
&lt;li&gt;第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。&lt;/li&gt;
&lt;/ul&gt;
&lt;footer&gt;&lt;strong&gt;阮一峰&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;搭建一个免费的，无限流量的Blog----github Pages和Jekyll入门&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;p&gt;大多数Blog作者，都停留在第一和第二阶段，因为第三阶段不太容易到达：你很难找到俯首听命、愿意为你管理服务器的人。&lt;/p&gt;
&lt;p&gt;但是现在Github和GitCafe等代码站都提供了Pages功能，只要将写好的文章提交到Github上托管，即可生成独立博客，而且提供几乎不限流量的存储空间，一切都是免费的。一旦搭建好，则只需要负责写文章就行了，不需要过多的管理。这不就是博客的第三阶段吗。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://vinnyxiong.cn/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://vinnyxiong.cn/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://vinnyxiong.cn//blog/hello-world.html"/>
    <id>http://vinnyxiong.cn//blog/hello-world.html</id>
    <published>2016-02-14T05:14:15.000Z</published>
    <updated>2016-03-02T11:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a><br><a id="more"></a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://vinnyxiong.cn/categories/Hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS多线程(三)：NSOperationQueue 的使用</title>
    <link href="http://vinnyxiong.cn//blog/nsoperation-and-nsoperationqueue-3.html"/>
    <id>http://vinnyxiong.cn//blog/nsoperation-and-nsoperationqueue-3.html</id>
    <published>2015-12-22T12:17:46.000Z</published>
    <updated>2016-03-01T02:13:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简单使用-NSOperationQueue"><a href="#1-简单使用-NSOperationQueue" class="headerlink" title="1 简单使用 NSOperationQueue"></a>1 简单使用 NSOperationQueue</h2><p>上一篇文章中看到使用自定义<code>NSOperation</code>来实现多线程，写法有些复杂，但其实，使用<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSOperationQueue_class/" target="_blank" rel="noopener"><code>NSOperationQueue</code></a>来实现多线程非常简单</p><figure class="highlight objc"><figcaption><span>VinnyOperation.m</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// 创建3个 NSInvocationOperation 操作</span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *opQueue = [<span class="built_in">NSOperationQueue</span> new];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 可以传递一个 NSObject 给operation的操作方法</span></span><br><span class="line">        <span class="built_in">NSDictionary</span> *dict = [<span class="built_in">NSDictionary</span> dictionaryWithObject:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Operation_%lu"</span>, i] forKey:<span class="string">@"key"</span>];</span><br><span class="line">        <span class="built_in">NSInvocationOperation</span> *op = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(operationSelector:) object:dict];</span><br><span class="line">        [opQueue addOperation:op];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// NSInvocationOperation 操作执行的方法</span></span><br><span class="line">- (<span class="keyword">void</span>)operationSelector:(<span class="built_in">NSDictionary</span> *)dict</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 接收传进来的dict</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dictValue = %@"</span>, [dict valueForKey:<span class="string">@"key"</span>]);</span><br><span class="line">    sleep(<span class="number">10</span>);  <span class="comment">// 加个睡眠模仿耗时操作</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"mainThread    = %@"</span>, [<span class="built_in">NSThread</span> mainThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果为：<a id="more"></a></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">16</span>:<span class="number">58</span>:<span class="number">18.282</span> test[<span class="number">57194</span>:<span class="number">18487531</span>] dictValue = Operation_0</span><br><span class="line"><span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">16</span>:<span class="number">58</span>:<span class="number">18.282</span> test[<span class="number">57194</span>:<span class="number">18487530</span>] dictValue = Operation_1</span><br><span class="line"><span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">16</span>:<span class="number">58</span>:<span class="number">18.282</span> test[<span class="number">57194</span>:<span class="number">18487533</span>] dictValue = Operation_2</span><br><span class="line"><span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">16</span>:<span class="number">58</span>:<span class="number">28.283</span> test[<span class="number">57194</span>:<span class="number">18487530</span>] currentThread = &lt;<span class="built_in">NSThread</span>: <span class="number">0x7fbf40435bb0</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">16</span>:<span class="number">58</span>:<span class="number">28.284</span> test[<span class="number">57194</span>:<span class="number">18487531</span>] currentThread = &lt;<span class="built_in">NSThread</span>: <span class="number">0x7fbf4050f2a0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">16</span>:<span class="number">58</span>:<span class="number">28.284</span> test[<span class="number">57194</span>:<span class="number">18487533</span>] currentThread = &lt;<span class="built_in">NSThread</span>: <span class="number">0x7fbf4290f560</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">16</span>:<span class="number">58</span>:<span class="number">28.284</span> test[<span class="number">57194</span>:<span class="number">18487530</span>] mainThread    = &lt;<span class="built_in">NSThread</span>: <span class="number">0x7fbf405058c0</span>&gt;&#123;number = <span class="number">1</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">16</span>:<span class="number">58</span>:<span class="number">28.284</span> test[<span class="number">57194</span>:<span class="number">18487531</span>] mainThread    = &lt;<span class="built_in">NSThread</span>: <span class="number">0x7fbf405058c0</span>&gt;&#123;number = <span class="number">1</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">16</span>:<span class="number">58</span>:<span class="number">28.284</span> test[<span class="number">57194</span>:<span class="number">18487533</span>] mainThread    = &lt;<span class="built_in">NSThread</span>: <span class="number">0x7fbf405058c0</span>&gt;&#123;number = <span class="number">1</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>可以看出来这三个操作是并发执行的，而且都不在主线程中执行。</p><h2 id="2-NSOperationQueue-的其他属性"><a href="#2-NSOperationQueue-的其他属性" class="headerlink" title="2 NSOperationQueue 的其他属性"></a>2 NSOperationQueue 的其他属性</h2><p>添加操作有3个方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接添加一个 NSOperation 操作，并且加入并发队列，只要当前队列允许，就会立刻执行。</span></span><br><span class="line">- (<span class="keyword">void</span>)addOperation:(<span class="built_in">NSOperation</span> *)op;</span><br><span class="line"><span class="comment">// 添加一组操作，如果 waitUntilFinished 为 NO，则必须在当前队列中的所有操作都执行完了，才会执行这组操作，否则立刻执行。</span></span><br><span class="line">- (<span class="keyword">void</span>)addOperations:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSOperation</span> *&gt; *)ops waitUntilFinished:(<span class="built_in">BOOL</span>)wait <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_6, <span class="number">4</span>_0);</span><br><span class="line"><span class="comment">// 直接在这里写一个block，block中的操作加入并发队列，并且只要当前队列允许执行，就会立刻执行。</span></span><br><span class="line">- (<span class="keyword">void</span>)addOperationWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_6, <span class="number">4</span>_0);</span><br></pre></td></tr></table></figure><p>接下来看其他的属性</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回当前队列中的所有操作NSOperation</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;__kindof <span class="built_in">NSOperation</span> *&gt; *operations;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回当前队列中的操作数量，对应 operations.count</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> operationCount <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_6, <span class="number">4</span>_0);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可读写的属性，当设备性能不足或根据需求要限制并行的操作数量时，可以设置这个值。</span></span><br><span class="line"><span class="comment">// 设置了这个值之后，队列中并发执行的操作数量不会大于这个值。超出这个值在排队中的操作会处于休眠状态。</span></span><br><span class="line"><span class="comment">// 默认值为 NSOperationQueueDefaultMaxConcurrentOperationCount = -1</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSInteger</span> maxConcurrentOperationCount;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以给队列指定一个名字用来做标识</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_6, <span class="number">4</span>_0);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给队列指定一个优先级，默认为 NSQualityOfServiceDefault = -1</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSQualityOfService</span> qualityOfService <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_10, <span class="number">8</span>_0);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ??? 这个不是太理解</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">assign</span> <span class="comment">/* actually retain */</span>) <span class="built_in">dispatch_queue_t</span> underlyingQueue <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_10, <span class="number">8</span>_0);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取消队列中的所有操作。其实就是调用 operations 中每个操作的`cancel`方法才取消操作。</span></span><br><span class="line"><span class="comment">// 但是，在前面的文章中说过，调用`cancel`方法并不会终止操作，而是设置`cancelled`属性为 YES，</span></span><br><span class="line"><span class="comment">// 这就需要自己在操作中分节点去判断`cancelled`属性了，在适当的时机结束操作。</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelAllOperations;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用这个方法时，会判断 NSOperationQueue 中的操作是否全部执行完，如果没有，则调用者所在的线程会在调用处等待。</span></span><br><span class="line"><span class="comment">// 直到 NSOperationQueue 中的所有操作执行完成，当前线程才继续执行。如果 NSOperationQueue 为空，则该方法立刻返回。</span></span><br><span class="line">- (<span class="keyword">void</span>)waitUntilAllOperationsAreFinished;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得调用者的当前线程中的 NSOperationQueue 操作队列</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSOperationQueue</span> *)currentQueue <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_6, <span class="number">4</span>_0);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得主线程中的 </span></span><br><span class="line">+ (<span class="built_in">NSOperationQueue</span> *)mainQueue <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_6, <span class="number">4</span>_0);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">getter</span>=isSuspended) <span class="built_in">BOOL</span> suspended;</span><br></pre></td></tr></table></figure><p>这个值很有意思，从字面意思理解是暂停队列，但是怎么个暂停呢？从官方文档上看</p><blockquote><p><strong>Discussion</strong><br>When the value of this property is NO, the queue actively starts operations that are in the queue and ready to execute. Setting this property to YES prevents the queue from starting any queued operations, but already executing operations continue to execute. You may continue to add operations to a queue that is suspended but those operations are not scheduled for execution until you change this property to NO.</p><p>Operations are removed from the queue only when they finish executing. However, in order to finish executing, an operation must first be started. Because a suspended queue does not start any new operations, it does not remove any operations (including cancelled operations) that are currently queued and not executing.</p><p>You may monitor changes to the value of this property using key-value observing. Configure an observer to monitor the suspended key path of the operation queue.</p><p>The default value of this property is NO.</p></blockquote><p>大概翻译一下，如果这个值设置为 NO，那说明这个队列已经准备好了可以执行了。如果这个值设置为 YES，那么已经添加到队列中的操作还是可以执行了，而后面继续添加进队列中的操作才处于<code>暂停</code>状态，直到你再次将这个值设置为 NO 时，后面加入的操作才会继续执行。这个属性的默认值是 NO。</p><p>来看一下使用的方法例子：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// 创建3个 NSInvocationOperation 操作</span></span><br><span class="line">    _opQueue = [<span class="built_in">NSOperationQueue</span> new];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 可以传递一个 NSObject 给operation的操作方法</span></span><br><span class="line">        <span class="built_in">NSDictionary</span> *dict = [<span class="built_in">NSDictionary</span> dictionaryWithObject:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Operation_%lu"</span>, i] forKey:<span class="string">@"key"</span>];</span><br><span class="line">        <span class="built_in">NSInvocationOperation</span> *op = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(operationSelector:) object:dict];</span><br><span class="line">        [_opQueue addOperation:op];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里设置为 YES</span></span><br><span class="line">    _opQueue.suspended = <span class="literal">YES</span>;</span><br><span class="line">    <span class="comment">// 然后再添加一个操作，序号为 9</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *dict = [<span class="built_in">NSDictionary</span> dictionaryWithObject:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Operation_%d"</span>, <span class="number">9</span>] forKey:<span class="string">@"key"</span>];</span><br><span class="line">    <span class="built_in">NSInvocationOperation</span> *op = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(operationSelector:) object:dict];</span><br><span class="line">    [_opQueue addOperation:op];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// NSInvocationOperation 操作执行的方法</span></span><br><span class="line">- (<span class="keyword">void</span>)operationSelector:(<span class="built_in">NSDictionary</span> *)dict</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 接收传进来的dict</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dictValue = %@"</span>, [dict valueForKey:<span class="string">@"key"</span>]);</span><br><span class="line">    sleep(<span class="number">10</span>);  <span class="comment">// 加个睡眠模仿耗时操作</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"mainThread    = %@"</span>, [<span class="built_in">NSThread</span> mainThread]);</span><br><span class="line">    <span class="comment">// 执行完其中一个操作之后把 suspended 改为 NO。</span></span><br><span class="line">    _opQueue.suspended = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">22</span>:<span class="number">07.546</span> test[<span class="number">57547</span>:<span class="number">18605364</span>] dictValue = Operation_2</span><br><span class="line"><span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">22</span>:<span class="number">07.546</span> test[<span class="number">57547</span>:<span class="number">18605360</span>] dictValue = Operation_0</span><br><span class="line"><span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">22</span>:<span class="number">07.546</span> test[<span class="number">57547</span>:<span class="number">18605361</span>] dictValue = Operation_1</span><br><span class="line"><span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">22</span>:<span class="number">10.547</span> test[<span class="number">57547</span>:<span class="number">18605361</span>] currentThread = &lt;<span class="built_in">NSThread</span>: <span class="number">0x7ff598d07b00</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">22</span>:<span class="number">10.547</span> test[<span class="number">57547</span>:<span class="number">18605364</span>] currentThread = &lt;<span class="built_in">NSThread</span>: <span class="number">0x7ff59a9784f0</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">22</span>:<span class="number">10.547</span> test[<span class="number">57547</span>:<span class="number">18605360</span>] currentThread = &lt;<span class="built_in">NSThread</span>: <span class="number">0x7ff59aa05100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">22</span>:<span class="number">10.547</span> test[<span class="number">57547</span>:<span class="number">18605364</span>] mainThread    = &lt;<span class="built_in">NSThread</span>: <span class="number">0x7ff598c08770</span>&gt;&#123;number = <span class="number">1</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">22</span>:<span class="number">10.547</span> test[<span class="number">57547</span>:<span class="number">18605360</span>] mainThread    = &lt;<span class="built_in">NSThread</span>: <span class="number">0x7ff598c08770</span>&gt;&#123;number = <span class="number">1</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">22</span>:<span class="number">10.547</span> test[<span class="number">57547</span>:<span class="number">18605361</span>] mainThread    = &lt;<span class="built_in">NSThread</span>: <span class="number">0x7ff598c08770</span>&gt;&#123;number = <span class="number">1</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">22</span>:<span class="number">10.547</span> test[<span class="number">57547</span>:<span class="number">18605513</span>] dictValue = Operation_9</span><br><span class="line"><span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">22</span>:<span class="number">13.620</span> test[<span class="number">57547</span>:<span class="number">18605513</span>] currentThread = &lt;<span class="built_in">NSThread</span>: <span class="number">0x7ff598c08ce0</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">22</span>:<span class="number">13.620</span> test[<span class="number">57547</span>:<span class="number">18605513</span>] mainThread    = &lt;<span class="built_in">NSThread</span>: <span class="number">0x7ff598c08770</span>&gt;&#123;number = <span class="number">1</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>可以看出来，操作9是在<code>suspended</code>改为 NO 之后才开始执行的。</p><p><strong>最后：</strong>以上很多属性都支持 KVO ，可以通过监听某个值的变化来做不同的操作，这里就不赘述了。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p><strong>NSOperationQueue</strong>为我们提供了非常简便的使用多线程的方法，如果需要使用<code>NSOperation</code>，则更多建议使用<code>NSOperationQueue</code>而不是自定义<code>NSOperation</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-简单使用-NSOperationQueue&quot;&gt;&lt;a href=&quot;#1-简单使用-NSOperationQueue&quot; class=&quot;headerlink&quot; title=&quot;1 简单使用 NSOperationQueue&quot;&gt;&lt;/a&gt;1 简单使用 NSOperationQueue&lt;/h2&gt;&lt;p&gt;上一篇文章中看到使用自定义&lt;code&gt;NSOperation&lt;/code&gt;来实现多线程，写法有些复杂，但其实，使用&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSOperationQueue_class/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;NSOperationQueue&lt;/code&gt;&lt;/a&gt;来实现多线程非常简单&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;figcaption&gt;&lt;span&gt;VinnyOperation.m&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)viewDidLoad &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 创建3个 NSInvocationOperation 操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSOperationQueue&lt;/span&gt; *opQueue = [&lt;span class=&quot;built_in&quot;&gt;NSOperationQueue&lt;/span&gt; new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 可以传递一个 NSObject 给operation的操作方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; *dict = [&lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; dictionaryWithObject:[&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; stringWithFormat:&lt;span class=&quot;string&quot;&gt;@&quot;Operation_%lu&quot;&lt;/span&gt;, i] forKey:&lt;span class=&quot;string&quot;&gt;@&quot;key&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSInvocationOperation&lt;/span&gt; *op = [[&lt;span class=&quot;built_in&quot;&gt;NSInvocationOperation&lt;/span&gt; alloc] initWithTarget:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; selector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(operationSelector:) object:dict];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [opQueue addOperation:op];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// NSInvocationOperation 操作执行的方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)operationSelector:(&lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; *)dict&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 接收传进来的dict&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;dictValue = %@&quot;&lt;/span&gt;, [dict valueForKey:&lt;span class=&quot;string&quot;&gt;@&quot;key&quot;&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sleep(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);  &lt;span class=&quot;comment&quot;&gt;// 加个睡眠模仿耗时操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;currentThread = %@&quot;&lt;/span&gt;, [&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;mainThread    = %@&quot;&lt;/span&gt;, [&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; mainThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;控制台输出结果为：
    
    </summary>
    
      <category term="iOS开发" scheme="http://vinnyxiong.cn/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="多线程" scheme="http://vinnyxiong.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="NSOperation" scheme="http://vinnyxiong.cn/tags/NSOperation/"/>
    
      <category term="NSInvocationOperation" scheme="http://vinnyxiong.cn/tags/NSInvocationOperation/"/>
    
      <category term="NSBlockOperation" scheme="http://vinnyxiong.cn/tags/NSBlockOperation/"/>
    
      <category term="NSOperationQueue" scheme="http://vinnyxiong.cn/tags/NSOperationQueue/"/>
    
  </entry>
  
  <entry>
    <title>iOS多线程(二)：NSOperation 自定义子类实现非并发和并发操作</title>
    <link href="http://vinnyxiong.cn//blog/nsoperation-and-nsoperationqueue-2.html"/>
    <id>http://vinnyxiong.cn//blog/nsoperation-and-nsoperationqueue-2.html</id>
    <published>2015-12-22T12:17:41.000Z</published>
    <updated>2016-03-01T02:12:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-自定义非并行的-NSOperation"><a href="#1-自定义非并行的-NSOperation" class="headerlink" title="1 自定义非并行的 NSOperation"></a>1 自定义非并行的 NSOperation</h2><p>前文介绍过 <a href="/blog/nsoperation-and-nsoperationqueue-1.html">NSInvocationOperation 和 NSBlockOperation</a> 都继承自NSOperation类。</p><p>我们亦可以通过继承 NSOperation 类，来自定义非并行的 Operation。</p><figure class="highlight objc"><figcaption><span>VinnyOperation.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">VinnyOperation</span> : <span class="title">NSOperation</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>头文件很简单，只需要继承 NSOperation ，可根据实际需要决定是否需要自定义<code>init</code>方法。而且仅仅需要自定义<code>main</code>方法，将需要执行的操作写在<code>main</code>方法中。</p><a id="more"></a><figure class="highlight objc"><figcaption><span>VinnyOperation.m</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"VinnyOperation.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">VinnyOperation</span></span></span><br><span class="line">- (<span class="keyword">void</span>)main</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"main begin"</span>);</span><br><span class="line">    <span class="keyword">@try</span> &#123;</span><br><span class="line">        <span class="comment">// 提供一个变量标识，来表示需要执行的操作是否完成了，当然，没开始执行之前，为NO</span></span><br><span class="line">        <span class="built_in">BOOL</span> taskIsFinished = <span class="literal">NO</span>;</span><br><span class="line">        <span class="comment">// while 保证：只有当没有执行完成和没有被取消，才执行自定义的相应操作</span></span><br><span class="line">        <span class="keyword">while</span> (taskIsFinished == <span class="literal">NO</span> &amp;&amp; [<span class="keyword">self</span> isCancelled] == <span class="literal">NO</span>)&#123;</span><br><span class="line">            <span class="comment">// 自定义的操作</span></span><br><span class="line">            sleep(<span class="number">10</span>);  <span class="comment">// 睡眠模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"currentThread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"mainThread    = %@"</span>, [<span class="built_in">NSThread</span> mainThread]);</span><br><span class="line">            <span class="comment">// 这里相应的操作都已经完成，后面就是要通知KVO我们的操作完成了。</span></span><br><span class="line">            taskIsFinished = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@catch</span> (<span class="built_in">NSException</span> * e) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Exception %@"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"main end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用的时候也非常简单</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VinnyOperation *op = [[VinnyOperation alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"start before"</span>);</span><br><span class="line">[op start];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"start after"</span>);</span><br></pre></td></tr></table></figure><p>看一下控制台打印的结果</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2015</span><span class="number">-12</span><span class="number">-29</span> <span class="number">19</span>:<span class="number">21</span>:<span class="number">56.895</span> test[<span class="number">67010</span>:<span class="number">50712745</span>] start before</span><br><span class="line"><span class="number">2015</span><span class="number">-12</span><span class="number">-29</span> <span class="number">19</span>:<span class="number">21</span>:<span class="number">56.896</span> test[<span class="number">67010</span>:<span class="number">50712745</span>] main begin</span><br><span class="line"><span class="number">2015</span><span class="number">-12</span><span class="number">-29</span> <span class="number">19</span>:<span class="number">22</span>:<span class="number">06.900</span> test[<span class="number">67010</span>:<span class="number">50712745</span>] currentThread = &lt;<span class="built_in">NSThread</span>: <span class="number">0x7fc560d044d0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2015</span><span class="number">-12</span><span class="number">-29</span> <span class="number">19</span>:<span class="number">22</span>:<span class="number">06.900</span> test[<span class="number">67010</span>:<span class="number">50712745</span>] mainThread    = &lt;<span class="built_in">NSThread</span>: <span class="number">0x7fc560d044d0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2015</span><span class="number">-12</span><span class="number">-29</span> <span class="number">19</span>:<span class="number">22</span>:<span class="number">06.900</span> test[<span class="number">67010</span>:<span class="number">50712745</span>] main end</span><br><span class="line"><span class="number">2015</span><span class="number">-12</span><span class="number">-29</span> <span class="number">19</span>:<span class="number">22</span>:<span class="number">06.900</span> test[<span class="number">67010</span>:<span class="number">50712745</span>] start after</span><br></pre></td></tr></table></figure><p>可以看出是<code>main</code>方法是非并行的，而且执行的操作与调用<code>start</code>是在同一个线程中。</p><h2 id="2-自定义并行的-NSOperation"><a href="#2-自定义并行的-NSOperation" class="headerlink" title="2 自定义并行的 NSOperation"></a>2 自定义并行的 NSOperation</h2><p>自定义并行的 NSOperation 则要复杂一点，首先必须重写以下几个方法：</p><ul><li><strong><code>start</code></strong>: 所有并行的 Operations 都必须重写这个方法，然后在你想要执行的线程中手动调用这个方法。<strong>注意：</strong>任何时候都不能调用父类的<code>start</code>方法。</li><li><strong><code>main</code></strong>: 在<code>start</code>方法中调用，但是注意要定义独立的自动释放池与别的线程区分开。</li><li><strong><code>isExecuting</code></strong>: 是否执行中，需要实现KVO通知机制。</li><li><strong><code>isFinished</code></strong>: 是否已完成，需要实现KVO通知机制。</li><li><strong><code>isConcurrent</code></strong>: 该方法现在已经由<code>isAsynchronous</code>方法代替，并且 NSOperationQueue 也已经忽略这个方法的值。</li><li><strong><code>isAsynchronous</code></strong>: 该方法默认返回 NO ，表示非并发执行。并发执行需要自定义并且返回 YES。后面会根据这个返回值来决定是否并发。</li></ul><p>与非并发操作不同的是，需要另外自定义一个方法来执行操作而不是直接调用<code>start</code>方法</p><figure class="highlight objc"><figcaption><span>MyOperation.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyOperation</span> : <span class="title">NSOperation</span></span></span><br><span class="line">- (<span class="built_in">BOOL</span>)performOperation:(<span class="built_in">NSOperation</span>*)anOp;    <span class="comment">// 执行操作调用这个方法</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>实现其中的必要方法：</p><figure class="highlight objc"><figcaption><span>MyOperation.m</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MyOperation.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyOperation</span> () </span>&#123;</span><br><span class="line">    <span class="built_in">BOOL</span>        executing;  <span class="comment">// 执行中</span></span><br><span class="line">    <span class="built_in">BOOL</span>        finished;   <span class="comment">// 已完成</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyOperation</span></span></span><br><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        executing = <span class="literal">NO</span>;</span><br><span class="line">        finished = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    <span class="comment">// Always check for cancellation before launching the task.</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Must move the operation to the finished state if it is canceled.</span></span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"isFinished"</span>];</span><br><span class="line">        finished = <span class="literal">YES</span>;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"isFinished"</span>];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If the operation is not canceled, begin executing the task.</span></span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"isExecuting"</span>];</span><br><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(main) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</span><br><span class="line">    executing = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"isExecuting"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)main &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"main begin"</span>);</span><br><span class="line">    <span class="keyword">@try</span> &#123;</span><br><span class="line">        <span class="comment">// 必须为自定义的 operation 提供 autorelease pool，因为 operation 完成后需要销毁。</span></span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="comment">// 提供一个变量标识，来表示需要执行的操作是否完成了，当然，没开始执行之前，为NO</span></span><br><span class="line">            <span class="built_in">BOOL</span> taskIsFinished = <span class="literal">NO</span>;</span><br><span class="line">            <span class="comment">// while 保证：只有当没有执行完成和没有被取消，才执行自定义的相应操作</span></span><br><span class="line">            <span class="keyword">while</span> (taskIsFinished == <span class="literal">NO</span> &amp;&amp; [<span class="keyword">self</span> isCancelled] == <span class="literal">NO</span>)&#123;</span><br><span class="line">                <span class="comment">// 自定义的操作</span></span><br><span class="line">                <span class="comment">//sleep(10);  // 睡眠模拟耗时操作</span></span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"currentThread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"mainThread    = %@"</span>, [<span class="built_in">NSThread</span> mainThread]);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 这里相应的操作都已经完成，后面就是要通知KVO我们的操作完成了。</span></span><br><span class="line">                taskIsFinished = <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            [<span class="keyword">self</span> completeOperation];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@catch</span> (<span class="built_in">NSException</span> * e) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Exception %@"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"main end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)completeOperation &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"isFinished"</span>];</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"isExecuting"</span>];</span><br><span class="line">    </span><br><span class="line">    executing = <span class="literal">NO</span>;</span><br><span class="line">    finished = <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"isExecuting"</span>];</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"isFinished"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已经弃用，使用 isAsynchronous 代替</span></span><br><span class="line"><span class="comment">//- (BOOL)isConcurrent &#123;</span></span><br><span class="line"><span class="comment">//    return NO;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isAsynchronous &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isExecuting &#123;</span><br><span class="line">    <span class="keyword">return</span> executing;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isFinished &#123;</span><br><span class="line">    <span class="keyword">return</span> finished;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行操作</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)performOperation:(<span class="built_in">NSOperation</span>*)anOp</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span>        ranIt = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([anOp isReady] &amp;&amp; ![anOp isCancelled])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (![anOp isAsynchronous]) &#123;</span><br><span class="line">            [anOp start];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(start)</span><br><span class="line">                                     toTarget:anOp withObject:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        ranIt = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([anOp isCancelled])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// If it was canceled before it was started,</span></span><br><span class="line">        <span class="comment">//  move the operation to the finished state.</span></span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"isFinished"</span>];</span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"isExecuting"</span>];</span><br><span class="line">        executing = <span class="literal">NO</span>;</span><br><span class="line">        finished = <span class="literal">YES</span>;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"isExecuting"</span>];</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"isFinished"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Set ranIt to YES to prevent the operation from</span></span><br><span class="line">        <span class="comment">// being passed to this method again in the future.</span></span><br><span class="line">        ranIt = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ranIt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这个 Operation 如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyOperation *op = [[MyOperation alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"start before"</span>);</span><br><span class="line">[op performOperation:op];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"start after"</span>);</span><br></pre></td></tr></table></figure><p>看一下控制台打印的结果</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2015</span><span class="number">-12</span><span class="number">-29</span> <span class="number">20</span>:<span class="number">01</span>:<span class="number">53.130</span> test[<span class="number">27083</span>:<span class="number">51105353</span>] start before</span><br><span class="line"><span class="number">2015</span><span class="number">-12</span><span class="number">-29</span> <span class="number">20</span>:<span class="number">01</span>:<span class="number">53.131</span> test[<span class="number">27083</span>:<span class="number">51105353</span>] start after</span><br><span class="line"><span class="number">2015</span><span class="number">-12</span><span class="number">-29</span> <span class="number">20</span>:<span class="number">01</span>:<span class="number">53.131</span> test[<span class="number">27083</span>:<span class="number">51105608</span>] main begin</span><br><span class="line"><span class="number">2015</span><span class="number">-12</span><span class="number">-29</span> <span class="number">20</span>:<span class="number">01</span>:<span class="number">53.131</span> test[<span class="number">27083</span>:<span class="number">51105608</span>] currentThread = &lt;<span class="built_in">NSThread</span>: <span class="number">0x7ff148d976d0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2015</span><span class="number">-12</span><span class="number">-29</span> <span class="number">20</span>:<span class="number">01</span>:<span class="number">53.131</span> test[<span class="number">27083</span>:<span class="number">51105608</span>] mainThread    = &lt;<span class="built_in">NSThread</span>: <span class="number">0x7ff148e01250</span>&gt;&#123;number = <span class="number">1</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2015</span><span class="number">-12</span><span class="number">-29</span> <span class="number">20</span>:<span class="number">01</span>:<span class="number">53.131</span> test[<span class="number">27083</span>:<span class="number">51105608</span>] main end</span><br></pre></td></tr></table></figure><p>可以看到这个操作是并发执行，并且是一个独立的线程。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><ol><li>如果需要自定义并发执行的 Operation，必须重写 <code>start</code>、<code>main</code>、<code>isExecuting</code>、<code>isFinished</code>、<code>isAsynchronous</code> 方法。</li><li>在 operation 的 main 方法里面，必须提供 autorelease pool,因为你的 operation 完成后需要销毁。</li><li>一旦你的 operation 开始了，必须通过 KVO，告诉所有的监听者，现在该operation的执行状态。</li><li>调用时，如果需要并发执行 Operation，必须调用<code>performOperation:</code>方法，当然，也可以改为自定义其他方法或者直接在<code>start</code>方法添加多线程调用。</li><li>对于自定义的 Operation 类，如果不需要并发执行，可以直接调用<code>start</code>方法。</li></ol><h2 id="4-尾巴"><a href="#4-尾巴" class="headerlink" title="4 尾巴"></a>4 尾巴</h2><p>刚开始看 NSOperation 的文档没搞明白怎么自定义多线程的操作，文档里只是说需要自定义 <code>isExecuting</code>、<code>isFinished</code>、<code>isConcurrent</code>、<code>isAsynchronous</code> 这四个方法，然后说根据 <code>isAsynchronous</code> 的返回值来判断是否多线程，我以为只要重写这个方法的时候返回 YES 就行了，NSOperation 就会自动多线程执行了，但是测试发现却不是这样的，多线程还得自己去创建再使用。</p><p>再有就是自定义多线程的 NSOperation 时，还必须自己管理其中表示状态的成员，而且需要实现 KVO 机制，使得这个过程复杂化了。</p><p>其实在大多数时候我们并不会直接去使用自定义的 NSOperation ，如果操作不复杂，可以直接使用 NSInvocationOperation 和 NSBlockOperation 这两个子类，那就直接用了，如果复杂一些，必须自定义又需要多线程，通常都会用 <strong>NSOperationQueue</strong> 来包装，使用起来更加简洁，下一篇会详细介绍 NSOperationQueue 的使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-自定义非并行的-NSOperation&quot;&gt;&lt;a href=&quot;#1-自定义非并行的-NSOperation&quot; class=&quot;headerlink&quot; title=&quot;1 自定义非并行的 NSOperation&quot;&gt;&lt;/a&gt;1 自定义非并行的 NSOperation&lt;/h2&gt;&lt;p&gt;前文介绍过 &lt;a href=&quot;/blog/nsoperation-and-nsoperationqueue-1.html&quot;&gt;NSInvocationOperation 和 NSBlockOperation&lt;/a&gt; 都继承自NSOperation类。&lt;/p&gt;
&lt;p&gt;我们亦可以通过继承 NSOperation 类，来自定义非并行的 Operation。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;figcaption&gt;&lt;span&gt;VinnyOperation.h&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;VinnyOperation&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSOperation&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;头文件很简单，只需要继承 NSOperation ，可根据实际需要决定是否需要自定义&lt;code&gt;init&lt;/code&gt;方法。而且仅仅需要自定义&lt;code&gt;main&lt;/code&gt;方法，将需要执行的操作写在&lt;code&gt;main&lt;/code&gt;方法中。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://vinnyxiong.cn/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="多线程" scheme="http://vinnyxiong.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="NSOperation" scheme="http://vinnyxiong.cn/tags/NSOperation/"/>
    
      <category term="NSInvocationOperation" scheme="http://vinnyxiong.cn/tags/NSInvocationOperation/"/>
    
      <category term="NSBlockOperation" scheme="http://vinnyxiong.cn/tags/NSBlockOperation/"/>
    
      <category term="NSOperationQueue" scheme="http://vinnyxiong.cn/tags/NSOperationQueue/"/>
    
  </entry>
  
  <entry>
    <title>iOS多线程(一)：NSInvocationOperation 和 NSBlockOperation 使用</title>
    <link href="http://vinnyxiong.cn//blog/nsoperation-and-nsoperationqueue-1.html"/>
    <id>http://vinnyxiong.cn//blog/nsoperation-and-nsoperationqueue-1.html</id>
    <published>2015-12-22T12:17:27.000Z</published>
    <updated>2016-03-29T01:36:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-NSOperation"><a href="#1-NSOperation" class="headerlink" title="1 NSOperation"></a>1 NSOperation</h2><p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSOperation_class/" target="_blank" rel="noopener">NSOperation</a> 自身是一个抽象类，定义了一个要执行的工作，可以定义一个 NSOperation 的子类来使用，只需要实现 NSOperation 的<code>main</code>方法，通过<code>start</code>方法来执行任务，默认是同步执行的，而如果需要支持并发工作，那么 NSOperation 子类还需要重写其他方法。</p><p>但是对于大多数业务来说，只需要使用系统定义的 NSOperation 的两个子类<code>NSInvocationOperation</code>和<code>NSBlockOperation</code>配合<code>NSOperationQueue</code>即可达到我们的需求。自定义 NSOperation 子类的方法后文再介绍。</p><a id="more"></a><h2 id="2-NSInvocationOperation"><a href="#2-NSInvocationOperation" class="headerlink" title="2 NSInvocationOperation"></a>2 NSInvocationOperation</h2><p>先来看看基本用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    // 可以传递一个 NSObject 给operation的操作方法</span><br><span class="line">    NSDictionary *dict = [NSDictionary dictionaryWithObject:@&quot;value1&quot; forKey:@&quot;key1&quot;];</span><br><span class="line">    NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(operationSelector:) object:dict];</span><br><span class="line">    NSLog(@&quot;start before&quot;);</span><br><span class="line">    [op start];</span><br><span class="line">    NSLog(@&quot;start after&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// NSInvocationOperation 操作执行的方法</span><br><span class="line">- (void)operationSelector:(NSDictionary *)dict</span><br><span class="line">&#123;</span><br><span class="line">    // 接收传进来的dict</span><br><span class="line">    NSLog(@&quot;dictValue = %@&quot;, [dict valueForKey:@&quot;key1&quot;]);</span><br><span class="line">    sleep(10);  // 加个睡眠模仿耗时操作</span><br><span class="line">    NSLog(@&quot;currentThread = %@&quot;, [NSThread currentThread]);</span><br><span class="line">    NSLog(@&quot;mainThread = %@&quot;, [NSThread mainThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>start</code>方法是在主线程执行的，控制台输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2015-12-24 12:51:48.369 test[32228:16046453] start before</span><br><span class="line">2015-12-24 12:51:48.369 test[32228:16046453] dictValue = value1</span><br><span class="line">2015-12-24 12:51:58.369 test[32228:16046453] currentThread = &lt;NSThread: 0x7fbfc0600a50&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-12-24 12:51:58.370 test[32228:16046453] mainThread    = &lt;NSThread: 0x7fbfc0600a50&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-12-24 12:51:58.370 test[32228:16046453] start after</span><br></pre></td></tr></table></figure><p>从输出结果可以看出，执行的操作方法与调用<code>start</code>的方法在<strong>同一个线程</strong>，并且是<strong>同步执行</strong>的。</p><h2 id="3-NSBlockOperation"><a href="#3-NSBlockOperation" class="headerlink" title="3 NSBlockOperation"></a>3 NSBlockOperation</h2><h3 id="3-1-NSBlockOperation-的基本用法"><a href="#3-1-NSBlockOperation-的基本用法" class="headerlink" title="3.1 NSBlockOperation 的基本用法"></a>3.1 NSBlockOperation 的基本用法</h3><p>NSBlockOperation 的使用也非常简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        sleep(10);  // 加个睡眠模仿耗时操作</span><br><span class="line">        NSLog(@&quot;currentThread = %@&quot;, [NSThread currentThread]);</span><br><span class="line">        NSLog(@&quot;mainThread = %@&quot;, [NSThread mainThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    NSLog(@&quot;start before&quot;);</span><br><span class="line">    [op start];</span><br><span class="line">    NSLog(@&quot;start after&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2015-12-24 13:01:46.440 test[91193:16257301] start before</span><br><span class="line">2015-12-24 13:01:56.442 test[91193:16257301] currentThread = &lt;NSThread: 0x7fd9aac03f30&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-12-24 13:01:56.442 test[91193:16257301] mainThread    = &lt;NSThread: 0x7fd9aac03f30&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-12-24 13:01:56.442 test[91193:16257301] start after</span><br></pre></td></tr></table></figure><p>可以看出，NSBlockOperation 与 NSInvocationOperation 的结果是一样的，Block 中的操作与<code>start</code>方法在<strong>同一个线程</strong>执行，并且是<strong>同步执行</strong>的。</p><h3 id="3-2-NSBlockOperation-多线程异步执行"><a href="#3-2-NSBlockOperation-多线程异步执行" class="headerlink" title="3.2 NSBlockOperation 多线程异步执行"></a>3.2 NSBlockOperation 多线程异步执行</h3><p>NSBlockOperation 还提供了这个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)addExecutionBlock:(void (^)(void))block;</span><br></pre></td></tr></table></figure><p>在上面的代码基础上扩展一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;BlockOperation 1 begin&quot;);</span><br><span class="line">        sleep(10);  // 加个睡眠模仿耗时操作</span><br><span class="line">        NSLog(@&quot;BlockOperation 1 currentThread = %@&quot;, [NSThread currentThread]);</span><br><span class="line">        NSLog(@&quot;BlockOperation 1 mainThread    = %@&quot;, [NSThread mainThread]);</span><br><span class="line">        NSLog(@&quot;BlockOperation 1 end&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;BlockOperation 2 begin&quot;);</span><br><span class="line">        sleep(10);</span><br><span class="line">        NSLog(@&quot;BlockOperation 2 currentThread = %@&quot;, [NSThread currentThread]);</span><br><span class="line">        NSLog(@&quot;BlockOperation 2 mainThread    = %@&quot;, [NSThread mainThread]);</span><br><span class="line">        NSLog(@&quot;BlockOperation 2 end&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;BlockOperation 3 begin&quot;);</span><br><span class="line">        sleep(10);</span><br><span class="line">        NSLog(@&quot;BlockOperation 3 currentThread = %@&quot;, [NSThread currentThread]);</span><br><span class="line">        NSLog(@&quot;BlockOperation 3 mainThread    = %@&quot;, [NSThread mainThread]);</span><br><span class="line">        NSLog(@&quot;BlockOperation 3 end&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;start before&quot;);</span><br><span class="line">    [op start];</span><br><span class="line">    NSLog(@&quot;start after&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2015-12-24 13:12:33.720 test[91459:16314387] start before</span><br><span class="line">2015-12-24 13:12:33.720 test[91459:16314387] BlockOperation 1 begin</span><br><span class="line">2015-12-24 13:12:33.720 test[91459:16314433] BlockOperation 3 begin</span><br><span class="line">2015-12-24 13:12:33.720 test[91459:16314432] BlockOperation 2 begin</span><br><span class="line">2015-12-24 13:12:43.725 test[91459:16314387] BlockOperation 1 currentThread = &lt;NSThread: 0x7fee1b507ef0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-12-24 13:12:43.726 test[91459:16314387] BlockOperation 1 mainThread    = &lt;NSThread: 0x7fee1b507ef0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-12-24 13:12:43.726 test[91459:16314387] BlockOperation 1 end</span><br><span class="line">2015-12-24 13:12:43.786 test[91459:16314433] BlockOperation 3 currentThread = &lt;NSThread: 0x7fee1ea08010&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-12-24 13:12:43.786 test[91459:16314432] BlockOperation 2 currentThread = &lt;NSThread: 0x7fee1b407cf0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2015-12-24 13:12:43.786 test[91459:16314432] BlockOperation 2 mainThread    = &lt;NSThread: 0x7fee1b507ef0&gt;&#123;number = 1, name = (null)&#125;</span><br><span class="line">2015-12-24 13:12:43.786 test[91459:16314433] BlockOperation 3 mainThread    = &lt;NSThread: 0x7fee1b507ef0&gt;&#123;number = 1, name = (null)&#125;</span><br><span class="line">2015-12-24 13:12:43.786 test[91459:16314432] BlockOperation 2 end</span><br><span class="line">2015-12-24 13:12:43.786 test[91459:16314433] BlockOperation 3 end</span><br><span class="line">2015-12-24 13:12:43.786 test[91459:16314387] start after</span><br></pre></td></tr></table></figure><p>看到 Block2 和 Block3 中的 currentThread 并不是主线程，而且其中的操作也是异步执行的。</p><p>可以看出如果是通过<code>addExecutionBlock</code>添加的操作则是<strong>多线程异步操作</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (readonly, copy) NSArray&lt;void (^)(void)&gt; *executionBlocks;</span><br></pre></td></tr></table></figure><p>这个只读属性得到添加进 NSBlockOperation 的所有 Block ，包括第一个。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>对于这两个 Operation ，如果仅使用同步执行操作，那么并没有多大的区别，一个是使用 selector 回调并可以传递参数进去，一个是使用 Block ，可根据实际情况选择。</p><p>但是如果想要使用多线程异步操作，则应该选择 NSBlockOperation，不过注意只有通过<code>addExecutionBlock</code>添加的操作才是多线程异步操作。</p><p>关于 NSInvocationOperation 和 NSBlockOperation 使用先介绍到这里。下一篇我们通过自定义<code>NSOperation</code>的子类，来实现更加灵活的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-NSOperation&quot;&gt;&lt;a href=&quot;#1-NSOperation&quot; class=&quot;headerlink&quot; title=&quot;1 NSOperation&quot;&gt;&lt;/a&gt;1 NSOperation&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSOperation_class/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NSOperation&lt;/a&gt; 自身是一个抽象类，定义了一个要执行的工作，可以定义一个 NSOperation 的子类来使用，只需要实现 NSOperation 的&lt;code&gt;main&lt;/code&gt;方法，通过&lt;code&gt;start&lt;/code&gt;方法来执行任务，默认是同步执行的，而如果需要支持并发工作，那么 NSOperation 子类还需要重写其他方法。&lt;/p&gt;
&lt;p&gt;但是对于大多数业务来说，只需要使用系统定义的 NSOperation 的两个子类&lt;code&gt;NSInvocationOperation&lt;/code&gt;和&lt;code&gt;NSBlockOperation&lt;/code&gt;配合&lt;code&gt;NSOperationQueue&lt;/code&gt;即可达到我们的需求。自定义 NSOperation 子类的方法后文再介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://vinnyxiong.cn/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="多线程" scheme="http://vinnyxiong.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="NSOperation" scheme="http://vinnyxiong.cn/tags/NSOperation/"/>
    
      <category term="NSInvocationOperation" scheme="http://vinnyxiong.cn/tags/NSInvocationOperation/"/>
    
      <category term="NSBlockOperation" scheme="http://vinnyxiong.cn/tags/NSBlockOperation/"/>
    
      <category term="NSOperationQueue" scheme="http://vinnyxiong.cn/tags/NSOperationQueue/"/>
    
  </entry>
  
  <entry>
    <title>UITextField限制字数的实现</title>
    <link href="http://vinnyxiong.cn//blog/limit-uitextfield-input-word-count.html"/>
    <id>http://vinnyxiong.cn//blog/limit-uitextfield-input-word-count.html</id>
    <published>2015-12-02T12:03:51.000Z</published>
    <updated>2016-03-29T01:23:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-常用实现方法"><a href="#1-常用实现方法" class="headerlink" title="1.常用实现方法"></a>1.常用实现方法</h2><p>iOS开发中，<code>UITextField</code>限制输入字数，我们可以重写<code>UITextFieldDelegate</code>中的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string;   // return NO to not change text</span><br></pre></td></tr></table></figure><p>每当有键盘事件改变<code>UITextField</code>的内容时，都会调用这个方法，如果要超出限制要禁止输入，返回<code>NO</code>即可。<br>实现方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)textLengthFromString:(NSString *)string</span><br><span class="line">&#123;</span><br><span class="line">    return [string lengthOfBytesUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string</span><br><span class="line">&#123;</span><br><span class="line">    if ([string length] &gt; 0)&#123;</span><br><span class="line">        NSString *textFieldString = [textField.text stringByReplacingCharactersInRange:range withString:string];</span><br><span class="line">        if ([self textLengthFromString:textFieldString] &gt; NameMaxLength)&#123;</span><br><span class="line">            return NO;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return  YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-遇到的问题"><a href="#2-遇到的问题" class="headerlink" title="2.遇到的问题"></a>2.遇到的问题</h2><p>以上方法对于监听键盘输入和退格删除都没有问题，但是，当我们使用粘贴或者直接在键盘上面点选文字输入（如下图）的时候，并不会调用这个方法。不知道<code>Apple</code>这种做法是什么原因，或许是我对这些方法的含义理解不深吧。</p><img src="/images/blog_post_images/2015-12/2015-12-02-limit-uitextfield-input-word-count.png"><h2 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3.解决方案"></a>3.解决方案</h2><p><code>UITextField</code>还可以监听很多的事件，这些事件是由<code>UIControlEvents</code>提供的，适用于<code>UITextField</code>的事件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UIControlEventEditingDidBegin     = 1 &lt;&lt; 16,     // UITextField</span><br><span class="line">UIControlEventEditingChanged      = 1 &lt;&lt; 17,</span><br><span class="line">UIControlEventEditingDidEnd       = 1 &lt;&lt; 18,</span><br><span class="line">UIControlEventEditingDidEndOnExit = 1 &lt;&lt; 19,     // &apos;return key&apos; ending editing</span><br></pre></td></tr></table></figure><p>对此，我们可以监听<code>UIControlEventEditingChanged</code>事件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.nameTextField addTarget:self action:@selector(textFieldEditChanged:) forControlEvents:UIControlEventEditingChanged];</span><br></pre></td></tr></table></figure><p>添加一个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 超出限制的时候截断</span><br><span class="line">- (void)textFieldEditChanged:(UITextField *)textField</span><br><span class="line">&#123;</span><br><span class="line">    if(textField.markedTextRange == nil &amp;&amp; [self textLengthFromString:textField.text] &gt; NameMaxLength)</span><br><span class="line">    &#123;</span><br><span class="line">        NSString *content = [self string:textField.text subStrWithUtf8Len:NameMaxLength];</span><br><span class="line">        textField.text = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>UITextField</code>中的内容改变的时候就会调用这个方法，如果超出了限制的长度，那么会对字符串进行截断，截断的方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 按照长度截断字符串</span><br><span class="line">- (NSString *)string:(NSString *)string subStrWithUtf8Len:(int)maxLen</span><br><span class="line">&#123;</span><br><span class="line">    int strlen = 0;</span><br><span class="line">    NSUInteger len = [string length];</span><br><span class="line">    int i= 0;</span><br><span class="line">    for(i= 0; i&lt; maxLen ; i++) &#123;</span><br><span class="line">        if(i&lt; len) &#123;</span><br><span class="line">            unichar wchar = [string characterAtIndex:i];</span><br><span class="line">            if(wchar &lt;= 127) &#123;</span><br><span class="line">                strlen++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                strlen += 3;</span><br><span class="line">            &#125;</span><br><span class="line">            if(strlen &gt; maxLen) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i &lt;= 0) &#123;</span><br><span class="line">        return string;</span><br><span class="line">    &#125;</span><br><span class="line">    NSString * str = [string substringWithRange:NSMakeRange(0,i)];</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用的是<code>UTF8</code>编码，如此，便可以解决限制<code>UITextField</code>输入文字长度的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-常用实现方法&quot;&gt;&lt;a href=&quot;#1-常用实现方法&quot; class=&quot;headerlink&quot; title=&quot;1.常用实现方法&quot;&gt;&lt;/a&gt;1.常用实现方法&lt;/h2&gt;&lt;p&gt;iOS开发中，&lt;code&gt;UITextField&lt;/code&gt;限制输入字数，我们可以重写&lt;code&gt;UITextFieldDelegate&lt;/code&gt;中的方法：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string;   // return NO to not change text&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;每当有键盘事件改变&lt;code&gt;UITextField&lt;/code&gt;的内容时，都会调用这个方法，如果要超出限制要禁止输入，返回&lt;code&gt;NO&lt;/code&gt;即可。&lt;br&gt;实现方式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (NSUInteger)textLengthFromString:(NSString *)string&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return [string lengthOfBytesUsingEncoding:NSUTF8StringEncoding];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ([string length] &amp;gt; 0)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSString *textFieldString = [textField.text stringByReplacingCharactersInRange:range withString:string];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if ([self textLengthFromString:textFieldString] &amp;gt; NameMaxLength)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return NO;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return  YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://vinnyxiong.cn/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="UITextField" scheme="http://vinnyxiong.cn/tags/UITextField/"/>
    
  </entry>
  
  <entry>
    <title>使用UISwitch重复调用UIControlEventValueChanged的问题解决方法</title>
    <link href="http://vinnyxiong.cn//blog/uiswitch-repeated-calls-uicontroleventvaluechanged-solution.html"/>
    <id>http://vinnyxiong.cn//blog/uiswitch-repeated-calls-uicontroleventvaluechanged-solution.html</id>
    <published>2015-12-02T08:21:53.000Z</published>
    <updated>2016-03-29T01:24:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-UISwitch的问题"><a href="#1-UISwitch的问题" class="headerlink" title="1.UISwitch的问题"></a>1.UISwitch的问题</h2><p><code>UISwitch</code>通常这样使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UISwitch *showPhoneNumSwitch = [[UISwitch alloc] initWithFrame:CGRectMake(80.f, 10.f, 100.f, 40.f)];</span><br><span class="line">[showPhoneNumSwitch setOn:YES];</span><br><span class="line">[showPhoneNumSwitch addTarget:self action:@selector(handleShowPhoneNumSwitch:) forControlEvents:UIControlEventValueChanged];</span><br></pre></td></tr></table></figure><p>监听<code>UIControlEventValueChanged</code>事件，当<code>UISwitch</code>的值改变时就会调用<code>handleShowPhoneNumSwitch</code>:方法，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void) handleShowPhoneNumSwitch:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">    UISwitch *switchButton = (UISwitch*)sender;</span><br><span class="line">    BOOL isOn = [switchButton isOn];</span><br><span class="line">    NSLog(@&quot;当前值是：%@&quot;, isOn ? @&quot;YES&quot; : @&quot;NO&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题来了</strong>，<a id="more"></a>如果手指在<code>UISwitch</code>控件上滑动，划出控件区域之后，手指不抬起，手指继续在屏幕上滑动，可以看到控制台一直在重复打印当前的状态，<br>如果我们直接在这个方法里面处理一些事务，比如提交网络请求，那么这些事务将重复执行完全一致的逻辑，消耗无谓的资源，甚至可能出现逻辑错误，比如下面这种逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void) handleShowPhoneNumSwitch:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">    UISwitch *switchButton = (UISwitch*)sender;</span><br><span class="line">    BOOL isOn = [switchButton isOn];</span><br><span class="line">    NSLog(@&quot;当前值是：%@&quot;, isOn ? @&quot;YES&quot; : @&quot;NO&quot;);</span><br><span class="line">    _isShowPhoneNum = isOn;</span><br><span class="line">    [[ServiceFactory service] requestModifyPhoneNumPrivacyConfig</span><br><span class="line">        :self.teamUin showPhoneNum: _isShowPhoneNum handler:^(uint32_t errorCode, id resp) &#123;</span><br><span class="line">        if (errorCode != 0) &#123;</span><br><span class="line">            [switchButton setOn:!_isShowPhoneNum animated:YES]; // 网络请求返回错误，这里给 UISwitch 设置了相反的值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上这种逻辑，在网络请求错误的时候，会把<code>UISwitch</code>的值设置为相反的值，如果这时候手指继续滑动，那么又会触发<code>UIControlEventValueChanged</code>进来这个方法，网络错误的地方又会设置相反的值，这样两种值交替出现。最终的效果可能是并非我们想要的效果。</p><h2 id="2-解决方案："><a href="#2-解决方案：" class="headerlink" title="2.解决方案："></a>2.解决方案：</h2><p>其实在手指滑动的时候，<code>UISwitch</code>的值并未发生改变，只是重复触发<code>UIControlEventValueChanged</code>，可以在方法内先进行一个判断，如果当前值跟上一次的值一样，那么就不需要执行方法里面的逻辑。<br>代码修正如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void) handleShowPhoneNumSwitch:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">    UISwitch *switchButton = (UISwitch*)sender;</span><br><span class="line">    BOOL isOn = [switchButton isOn];</span><br><span class="line">    if (isOn != _isShowPhoneNum) &#123;// 判断是否与上次进来相同</span><br><span class="line">        _isShowPhoneNum = isOn;</span><br><span class="line">        [[ServiceFactory service] requestModifyPhoneNumPrivacyConfig</span><br><span class="line">            :self.teamUin showPhoneNum: _isShowPhoneNum handler:^(uint32_t errorCode, id resp) &#123;</span><br><span class="line">            if (errorCode != 0) &#123;</span><br><span class="line">               _isShowPhoneNum = !isOn;</span><br><span class="line">               [switchButton setOn:_isShowPhoneNum animated:YES];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>_isShowPhoneNum</code>可以作为成员变量，先初始化为<code>UISwitch</code>的初始值，当<code>_isShowPhoneNum</code>与当前值相同时，不需要执行里面的逻辑。</p><p><strong>吐槽：</strong>这个控件如果手指滑动之后没有抬起继续滑动，就会不断地触发<code>UIControlEventValueChanged</code>，怎么看都不合理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-UISwitch的问题&quot;&gt;&lt;a href=&quot;#1-UISwitch的问题&quot; class=&quot;headerlink&quot; title=&quot;1.UISwitch的问题&quot;&gt;&lt;/a&gt;1.UISwitch的问题&lt;/h2&gt;&lt;p&gt;&lt;code&gt;UISwitch&lt;/code&gt;通常这样使用：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UISwitch *showPhoneNumSwitch = [[UISwitch alloc] initWithFrame:CGRectMake(80.f, 10.f, 100.f, 40.f)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[showPhoneNumSwitch setOn:YES];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[showPhoneNumSwitch addTarget:self action:@selector(handleShowPhoneNumSwitch:) forControlEvents:UIControlEventValueChanged];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;监听&lt;code&gt;UIControlEventValueChanged&lt;/code&gt;事件，当&lt;code&gt;UISwitch&lt;/code&gt;的值改变时就会调用&lt;code&gt;handleShowPhoneNumSwitch&lt;/code&gt;:方法，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void) handleShowPhoneNumSwitch:(id)sender&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UISwitch *switchButton = (UISwitch*)sender;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BOOL isOn = [switchButton isOn];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&amp;quot;当前值是：%@&amp;quot;, isOn ? @&amp;quot;YES&amp;quot; : @&amp;quot;NO&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;问题来了&lt;/strong&gt;，
    
    </summary>
    
      <category term="iOS开发" scheme="http://vinnyxiong.cn/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="UISwitch" scheme="http://vinnyxiong.cn/tags/UISwitch/"/>
    
  </entry>
  
</feed>
